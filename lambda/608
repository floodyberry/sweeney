<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>expressivity of &quot;idiomatic C++&quot; | Lambda the Ultimate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<base href="http://lambda-the-ultimate.org/" />
<style type="text/css" media="all">@import "misc/drupal.css";</style> <link rel="SHORTCUT ICON" href="favicon.ico"> <link rel="stylesheet" type="text/css" href="themes/chameleon/common.css" />
<style type="text/css" media="all">@import "themes/chameleon/ltu/style.css";</style></head><body>
 <div id="header">  <h1 class="site-name title"><a href="">Lambda the Ultimate</a></h1>  <img src="themes/chameleon/ltu/tagline.png" alt="The Programming Languages Weblog" /><div id="search-form" style="text-align:right;"><form action="search" method="post">  <input class="form-text" type="text" size="15" value="" name="edit[keys]" id="edit-keys" />&nbsp;  <input class="form-submit" type="submit" value="Search" />&nbsp;</form></div>
</div>
 <table id="content">
  <tr>
   <td id="sidebar-left"><div class="block block-block" id="block-block-1">
 <h2 class="title"></h2>
 <div class="content"><b>
<div style="text-align:right">
<p>
<a href="/rss.xml"><img src="/misc/xml.gif" border=0 /></a><p>
<a href="/">Home</a><p>
<a href="/node/view/34">Feedback</a><p>
<a href="/node/view/40">FAQ</a><p>
<a href="/forum/1">Discussions</a><p>
<a href="/forum/2">Site operation discussions</a><p>
<a href="/tracker">Recent Posts</a><p>
<a href="/node/add/forum/1">(new topic)</a><p>
<a href="/node/view/49">Departments</a><p>
<a href="/node/view/2">Courses</a><p>
<a href="/node/view/4">Research Papers</a><p>
<a href="/node/view/3">Design Docs</a><p>
<a href="/node/view/5">Quotations</a><p>
<a href="/node/view/7">Genealogical Diagrams</a><p>
<a href="/classic/lambda-archive1.html">Archives</a>
</div>
</b>
<hr style="border-width:0 0 1px 0" />
</div>
</div>
<div class="block block-user" id="block-user-0">
 <h2 class="title">User login</h2>
 <div class="content"><form action="user/login?destination=node%2F608" method="post">
<div class="user-login-block">
<div class="form-item">
 <label for="edit-name">Username:</label><br />
 <input type="text" maxlength="64" class="form-text" name="edit[name]" id="edit-name" size="15" value="" />
</div>
<div class="form-item">
 <label for="edit-pass">Password:</label><br />
 <input type="password" class="form-password" maxlength="64" name="edit[pass]" id="edit-pass" size="15" value="" />
</div>
<input type="submit" class="form-submit" name="op" value="Log in"  />
</div>

</form>
<div class="item-list"><ul><li><a href="user/register" title="Create a new user account.">Create new account</a></li><li><a href="user/password" title="Request new password via e-mail.">Request new password</a></li></ul></div></div>
</div>
<div class="block block-user" id="block-user-1">
 <h2 class="title">Navigation</h2>
 <div class="content"><div class="menu">
<ul>
<li class="leaf"><a href="tracker">recent posts</a></li>

</ul>
</div></div>
</div>
</td>
   <td id="main">
<div class="breadcrumb"><a href="">Home</a> &raquo; <a href="forum">forums</a> &raquo; <a href="forum/1">LtU Forum</a></div><h2>expressivity of &quot;idiomatic C++&quot;</h2>
<!-- begin content -->
<div class="node">
 <div class="content">
<p>The April issue of <a href="http://www.cuj.com/"><em>C/C++ Users
Journal</em></a> has an article called <em>A New Solution To an Old Problem</em>
by Andrew Koenig and Barbara E. Moo.  In it, they revisit the <em><a
href="http://www.google.com/search?q=Hamming+numbers+Haskell">Hamming
numbers</a></em> problem from Dijkstra's <a
href="http://www.google.com/search?q=ISBN+013215871X"><em>A Discipline of
Programming</em></a>.
</p>

<p>They examine four different solutions:</p>

<ol>
  <li>A naive <code>O(n^2)</code> solution.</li>
  <li>Dijkstra's efficient but somewhat convoluted <code>O(n)</code> solution
    (re)implemented in C++.
  </li>
  <li>An elegant <code>O(n)</code> solution in Haskell.</li>
  <li>Their own new <code>O(n*log(n))</code> solution in "idiomatic C++".</li>
</ol>

<p>The Haskell solution is the following</p>

<pre>
scale n (x:xs) = (n * x) : (scale n xs)
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
   if x == y then
      x : (merge xs ys)
   else if x &lt; y then
      x : (merge xs (y:ys))
   else
      y : (merge (x:xs) ys)

seq = 1 : (merge (scale 2 seq)
                 (merge (scale 3 seq) (scale 5 seq)))
</pre>

<p>Their "idiomatic C++" solution uses ordered sets:</p>


<pre>
set&lt;int> seq;
seq.insert(1);
set&lt;int>::const_iterator it = seq.begin();

int val = *it;
seq.insert(val * 2);
seq.insert(val * 3);
seq.insert(val * 5);
it++;
</pre>

<p>In conclusion, they have this to say (emphasis mine), </p>

<blockquote>

<p>We have looked at four solutions to a simple problem.  The first was
straightforward but slow.  The second was much faster but fairly tricky.  The
third, in a functional language, was again straightforward -- <strong>but requires a
totally different way of thinking about programming.</strong> Indeed, advocates of
this way of thinking use the program's straightforwardness to argue that this
way of thinking is superior.</p>

<p>With the fourth solution, we believe that the argument is far from
obvious.</p>
</blockquote>

<p>I may be reading too much into this quote, but it sounds to me like Koenig
and Moo consider it a bad thing to require a "totally different way of thinking
about programming". </p>

<p>P.S. While googling for <em>Hamming numbers</em>, I came across this related
paper: <a
href="http://lml.ls.fi.upm.es/~jjmoreno/jjpapers/expr_imp.ps"><em>Expressivity of
Functional-Logic Languages and Their Implementation</em></a> by Juan Jos&eacute; Moreno
Navarro.
</p>
 </div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at 03/29/2005 - 15:22 | <a href="taxonomy/term/1">LtU Forum</a> | <a href="node/1684" title="Closures for Java or money back">previous forum topic</a> | <a href="node/1716" title="linux vs windows which is more compatible">next forum topic</a> | <a href="http://www.technorati.com/search/lambda-the-ultimate.org/node/608" title="Technorati search of other blogs commenting on this post.">other blogs</a> | 13840 reads</div>
</div>
<a id="comment"></a>
<form method="post" action="comment"><div>
<h2 class="title">Comment viewing options</h2><div><div class="form-item">
 <select name="mode"> <option value="1">Flat list - collapsed</option>
 <option value="2">Flat list - expanded</option>
 <option value="3">Threaded list - collapsed</option>
 <option value="4" selected="selected">Threaded list - expanded</option>
</select>
<select name="order"> <option value="1">Date - newest first</option>
 <option value="2" selected="selected">Date - oldest first</option>
</select>
<select name="comments_per_page"> <option value="10">10 comments per page</option> <option value="30">30 comments per page</option> <option value="50">50 comments per page</option> <option value="70">70 comments per page</option> <option value="90">90 comments per page</option> <option value="150">150 comments per page</option> <option value="200">200 comments per page</option></select>
<input type="hidden" name="threshold" value="0" />
 <input type="submit" class="form-submit" name="op" value="Save settings"  />

 <div class="description">Select your preferred way to display the comments and click "Save settings" to activate your changes.</div>
</div>
</div><input type="hidden" name="edit[nid]" value="608" />
</div></form><form method="post" action="comment"><div>
<input type="hidden" name="edit[nid]" value="608" />
<a id="comment-5112"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5112" class="active">FP as a second language</a></h3>
 <div class="content"><p ><i >but it sounds to me like Koenig and Moo consider it a bad thing to require a "totally different way of thinking about programming".</i></p>
<p >Of course they do.  Remember that one of the core design values of C++ is building upon pre-existing knowledge and expectations from C.  I think there is an inherent conservativeness in the C/C++ community, partly because of this value and partly because they are the "powers that be" in many programming domains.</p>
<p >I should point out that, though I don't share that PL conservative outlook, I don't think it is unreasonable either.  If you have spent many years mastering a particular "way of thinking about programming", you probably aren't going to want to give it up on short notice.</p>
<p >No one wants to go from being a doctor or engineer in his "native" PL to being a taxi driver in someone else's.</p>
<p >I think a lot of technological "religion" flows from exactly this kind of learning opportunity cost.</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Tue, 03/29/2005 - 15:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5115"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5115" class="active">Agreed</a></h3>
 <div class="content"><p >First, it's a fair observation that when you're faced with a problem and someone proposes a paradigm shift as a solution, you should explore all other avenues first, because paradigm shifts are high-cost events by definition. Given this, it's not clear to me that Koenig and Moo are necessarily hostile to FP, and in fact anyone who writes forcefully about taking full advantage of the STL, as Koenig and Moo have done, can't be all <em >that</em> hostile to it!</p>
<p >However, even if I'm mistaken on that last point, it doesn't mean that the entirety of the C++ community agrees, or even that people who are on the standards committee agree: witness Bjarne Stroustrup's insistence that C++ is multiparadigm including functional programming, boost::lambda, FC++, and Phoenix. Also, boost::lambda and Phoenix are being integrated, and hopefully at some future date we'll also see monads make it from FC++ into whatever the integrated boost functional programming library is called.</p>
<p >It pains me to say it... but C++ is my fourth-favorite functional language. That may not sound like much, but the fact that it's on my list at all just flabbergasts me. For the curious, my first three are Oz, O'Caml, and the Lisp family.</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Tue, 03/29/2005 - 16:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5117"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5117" class="active">on paradigmatic shifts</a></h3>
 <div class="content"><blockquote>it's a fair observation that when you're 
faced with a problem and someone proposes a paradigm 
shift as a solution, you should explore all other avenues
first, because paradigm shifts are high-cost events by 
definition.</blockquote>

<p>STL <em>was</em> a paradigm shift at the time it was 
introduced, was it not?</p></div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 03/29/2005 - 17:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5257"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5257" class="active">So was OO</a></h3>
 <div class="content"><p >This is the big advantage C++ has- even over other "Object Oriented C" languages (like Objective-C).  It provides the new "paradigm" (or pseudo-paradigm- I don't think templates in C++ or modules in Ocaml quite qualify as full on paradigms by themselves) without really requiring it.  You can ignore it if you don't understand it or don't understand it well enough to use it right now.  I still know a number of programmers supposedly programming in C++ whose code looks awfully similiar to C.</p>
<p >Note that this is also a disadvantage of C++, in that code written by one programmer who "knows" the language is not necessarily understandable by another programmer who "knows" the language.</p></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Mon, 04/04/2005 - 22:04 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5258"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5258" class="active">Surely you mean that code wri</a></h3>
 <div class="content"><p >Surely you mean that code written by a programmer who knows the language may not be comprehensible to one who "knows" (i.e. doesn't know) the language?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Mon, 04/04/2005 - 22:30 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-5262"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5262" class="active">Known Knowns :-)</a></h3>
 <div class="content"><p >I think his point was that it's quite possible (actually, common) for one C++ programmer to know the language from one angle and another programmer to know it from another angle, and for each of these programmers to find the other's code incomprehensible, even though they're both writing perfectly valid ANSI C++.</p>
<p >I encounter this phenomenon a lot: I make no apologies for the fact that my C++ style is very much driven by the modern capabilities of the language and libraries coupled with my background as a Lisp and, nowadays, O'Caml programmer. Folks who come to C++ with what I think of as the MFC (or, to be fair, MacApp) perspective frequently find my code incomprehensible (I pasted some compiling, but not working, source code into a chat with other C++ programmers with over a decade's experience and had one of them seriously challenge the idea that the code would even compile). Conversely, I find code written in the rely-on-members-in-a-superclass-to-side-effect-a-data-member-that-I-rely-on, coupled with plain-ol'-public-data-members, style utterly incomprehensible as well.</p>
<p >C++ now supports multiple diametrically opposed styles and their associated communities. This is something that it has in common with Perl. I leave you to draw your own conclusions about that.</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Tue, 04/05/2005 - 01:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-5276"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5276" class="active">Yes- that was precisely what I meant</a></h3>
 <div class="content"><p >In my experience, there are three main "styles" of C++ programmers I've seen:</p>
<p >First, there is C-with-classes programmer.  These people are comming out of the C world, and they're not really comfortable with all these new-fangled stuff.  Often times, there code will compile and run perfectly fine on a straight C compiler.  Most of the rest use the occasional class or STL library, but not often.  You'd have to change maybe 1% of the code to get it to compile as C.  The red flag that you're dealing with a C-with-classes programmers is when you can do:<br >
#define class struct<br >
and everything still pretty much works.</p>
<p >Next up is the Java++ programmer.  These are people comming out of the Java, Python, Ruby, etc. world.  And they are still programming in said languages.  They use objects a lot, but avoid using features not in these languages, like pointer arithmetic, templates, operator overloading, etc.  The red flag that you're dealing with a Java++ programmer is when you start seeing classes with only virtual member functions all over the place (that's how you implement an interface, see...).  Also, a tendancy to allocate everything on the heap and unbox almost nothing is also a common warning sign.</p>
<p >Lastly, there is the he-man C++ programmer.  Generally, these people don't really know another language- several of them may have learned Pascal or Scheme back in college, but they're "grown-ups" using "grown-up languages" now (just ask them), but an increasing number of them learned C++ as their first language and never moved on.  These programmers have memorized everything Bjarne Stroustrup ever wrote, and are out to  prove it.  The red flag that you're dealing with a he-man C++ programmer is that you find yourself having to look up what a private const static virtual constructor means, because that's critical to understanding why the code even works.  He-man C++ programmers love template metaprogramming, which is possibly the most damning thing I can say about them. He-man C++ programmers never, ever eat quiche.</p></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Tue, 04/05/2005 - 14:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-5277"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5277" class="active">In my experience, there is a</a></h3>
 <div class="content">In my experience, there is a fourth category: Those who wish they were in the third, but don't know enough C++ to pull it off. Warning sign: writing libraries that replicate existing libraries to augment C++, or writing libraries to duplicate functionality alreay present in the standard language, because they don't know about it.<p>
In fairness, though, plenty of C++ code uses a lot of classes, as it is written by people who have graduated beyond the first category, but have yet to discover "advanced" features like STL, templates, or operator overloading in any meaningful way, or don't really need it that much, to grind out code.</div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 04/05/2005 - 14:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:200px;">
<a id="comment-5288"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5288" class="active">Be carefull about who you call advanced</a></h3>
 <div class="content"><p >There's a natural tendancy to assume I listed the classes from least advanced to most advanced.  Well, OK- the c-with-classes folks generally really don't know C++.  But I tend to fall into the Java++ class, despite knowing all about templates, operator overloading, etc.  Simply because a language provides a feature doesn't mean you should use it at every opportunity- as the IOCCC shows.  And while the Java++ programmers may be ignorant of the more obscure corners of the languages, He-man C++ programmers are just as commonly (in my experience) ignorant of Design Patterns.  I've seen He-man C++ programmers be completely baffled by the code written by Java++ programmers.  Not that they didn't understand the mechanics of how the code worked, but because they didn't understand the metaphors and patterns the Java++ programmer was using.</p></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Tue, 04/05/2005 - 18:30 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:225px;">
<a id="comment-5296"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5296" class="active">You do know what quotes signi</a></h3>
 <div class="content"><p >You do know what quotes signify, right?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 04/05/2005 - 20:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:250px;">
<a id="comment-5313"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5313" class="active">Yes</a></h3>
 <div class="content"><p >And I meant them.</p>
<p >Simply because you're up on the syntax and semantics of C++ doesn't necessarily make you a superior programmer over the guy who just got introduced to the language a week ago.</p></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Wed, 04/06/2005 - 13:11 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:275px;">
<a id="comment-5317"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5317" class="active">No, But...</a></h3>
 <div class="content"><p >...like money buying you happiness, it certainly helps a lot!</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Wed, 04/06/2005 - 15:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:275px;">
<a id="comment-5318"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5318" class="active">I meant in English. Simply be</a></h3>
 <div class="content"><p >I meant in English. Simply because you can think up snide asides doesn't make you more articulate.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Wed, 04/06/2005 - 15:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-21008"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-21008" class="active">stereotyping is not very constructive, and...</a></h3>
 <div class="content"><blockquote ><p >
The red flag that you're dealing with a C-with-classes programmers is when you can do:<br >
#define class struct<br >
and everything still pretty much works.
</p></blockquote>
<p >by language definition every c++ program works just as well with the above macro applied. have a look at the c++ standard to figure out why...</p>
<p >you should at least support your overgeneralizing critique by providing correct accusations.</p>
<p >in my personal experience i have met just as many close-minded and/or incompetent c++ programmers as i have met such persons in most other language community of your choice. attitude and skill is usually not directly related to programming language preference.</p></div>
 <div class="links">By <a href="user/2535" title="View user profile.">peter steiner</a> at Sat, 09/09/2006 - 20:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5118"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5118" class="active">Look at the wookie!</a></h3>
 <div class="content">Disclaimer: following honored traditions pioneered at Slashdot, I haven't read the article being referred to.  But I'm going to rip into it anyway. :)
<blockquote>
<p>
If you have spent many years mastering a particular "way of thinking about programming", you probably aren't going to want to give it up on short notice.
</p><p>
No one wants to go from being a doctor or engineer in his "native" PL to being a taxi driver in someone else's.
</p><p>
I think a lot of technological "religion" flows from exactly this kind of learning opportunity cost.
</blockquote>
<p>
True, and it results in a pretty irrational argument on the part of the authors of this article.
</p><p>
On the one hand, the article implicitly demonstrates the benefits of considering multiple approaches to solving a problem, in that by doing so, we can find solutions that meet a desired balance between e.g. expressivity and performance.  That's how they achieved their new solution, after all.
</p><p>
OTOH, the implied conclusion is (apparently) that a major part of the possible solution space - i.e. functional solutions - should be excluded from consideration in general.
</p><p>
The reason for excluding such solutions boils down to the fact that they've previously been excluded, which is why something as simple as a basic recursive solution to a problem is seen as a "totally different way of thinking about programming".  The reasoning is circular (dare I say recursive?)  There's no underlying logic here, other than the need to defend a knowledge gap that exists for historical reasons.  The same argument could have been made against using STL-based code in the first place.
</p><p>
To hide this weak argument, they've resorted to major obfuscation &mdash; conflating issues arising from different paradigms, different languages, different algorithms, differing amounts of library support, and implied issues like side-effect free programming, all without making any attempt to tease the issues apart.  To top it all off, we are to believe that this single, highly confused example has some bearing on the general case.  
</p><p>
All in all, we're dealing with the <a href="http://en.wikipedia.org/wiki/Chewbacca_Defense">Chewbacca defense</a>.
</p>
</div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Tue, 03/29/2005 - 17:49 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5120"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5120" class="active">another quote from the article&#039;s Conlusion</a></h3>
 <div class="content"><blockquote>the implied conclusion is (apparently) that
a major part of the possible solution space - i.e. 
functional solutions - should be excluded from
consideration in general.</blockquote>

<p>I don't believe this is a fair characterization of K
&amp; M's conclusion. Let me give you another 
out-of-context quote from the same piece:</p>

<blockquote>It is not essential to master every detail 
of every tool that you might ever need to use.  What is
essential is knowing that the tools exist, being open 
to the possibility of using them, and being willing to 
learn to how to use them when they are likely to be 
useful.</blockquote>

<p>Thanks for <em>Chewbacca Defense</em> link by the 
way.  I've been using the term ever since I saw the 
South Park episode in which this notion was introduced. 
I didn't realize, however, that the term had gained 
such wide recognition.</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 03/29/2005 - 18:11 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5142"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5142" class="active">Not buying it</a></h3>
 <div class="content">Koenig & Moo wrote:
<blockquote>
It is not essential to master every detail of every tool that you might ever need to use. What is essential is knowing that the tools exist, being open to the possibility of using them, and being willing to learn to how to use them when they are likely to be useful.
</blockquote>
<p>
I agree with this point in general, but it doesn't save the authors in this case.  If someone is at a point where FP seems to require learning "a totally different way of thinking about programming", they're not going to meaningfully be able to keep that as a readily available option in their toolbox.  Suddenly learning all about FP right at the point when it is "likely to be useful" isn't a great strategy.  In any case, the comments you quoted do seem to imply something about the authors' opinion on the merits of investing in learning that different way of programming.
</p><p>
A big problem I have with all of this is what, specifically, the bogeyman is here &mdash; what are the elements of the "different way of thinking" they see as being required for the FP solution to this particular problem.
</p><p>
Presumably the problem isn't Haskell syntax in general, since that's a specific language issue, rather than anything intrinsic to the notion of FP.  You could implement the same sort of code in C++.
</p><p>
If the problem is recursion, then what we're really talking about is the fact that mainstream languages have done a poor job of implementing recursion, <i>primarily because they didn't know any better at the time</i>.  So while recursive solutions may be a totally different way of thinking about programming for some people, that's only because they've been Sapir-Whorfed into partial ignorance by the languages they use.  The "different way of thinking" that is required here actually involves unlearning old limitations on thinking, and the only possibly valid argument against doing so is if the language you're using still doesn't support recursion well.
</p><p>
I can't imagine that the pattern matching is the issue &mdash; non-FP languages have that too, Python comes to mind.  The lack of mutation in Haskell might be more of a concern, but that's somewhat orthogonal to real-world FP, and it's not news to anyone that mutation can have convenience and performance advantages.  
</p><p>
In all these cases, the real issues involve learning principles which are more general, more widely applicable, than their specific expression in any single language, particularly mainstream languages.  I would hope that someone who's actually teaching students would recognize this.  
</p></div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Wed, 03/30/2005 - 06:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5339"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5339" class="active">Myths and ideology in programming</a></h3>
 <div class="content"><p>Here is how my girlfriend, a literary critic, would analyze this.

<p>According to Roland Barthes, a myth is an artificial cultural artifact which is presented as timeless, universal and natural. You can find examples in nationalism, advertising and media. Judging from the quoted text of the article, it sounds like the authors are using myths to reinforce a power structure where pedants and celebrities exert control over programmers and users.

<p>The whole "different way of thinking" thing is part of the imperative ideology. It's a bogeyman playing on xenophobia that is used to make people uncomfortable about competing paradigms, and keep them in the fold of a community (culture) where what they read and hear can be controlled and censored.

<p>They write that the FP approach is "straightforward -- but requires a totally different way of thinking about programming." Hm? It is both straightforward <em>and</em> "totally" alien? This borders on contradiction. Indeed, if a person can grasp the FP solution without having done any actual functional programming, just by reading a short article, and moreover regard it as "straightforward", one can hardly claim it is a "totally different way of thinking". Even if it is totally different from imperative thinking, whatever that is, it may not be incompatible with other sorts of thinking habits which their audience might broadly share. After all, we all get taught about equations, functions and, to some extent, recursion in high school. (At least factorial and the chain rule.) How alien can it be?

<p>To be fair, though, there is also an FP (and LP) myth that because FP is "based on" mathematics it is natural and hence superior to procedural and OO paradigms. But mathematics is a cultural and historical artifact. I do not mean that mathematical truths are relative; I mean that the body of mathematical literature has taken a form which is a historical accident. For example, mathematics is often divided into geometry, analysis and algebra, but this could as easily have been geometry, analysis and coalgebra, in which case OOP advocates could have exploited this myth, OO being rather coalgebraic in nature.

<p>Don't get me wrong. I think that there is a genuinely closer relationship between mathematical truth and FP, because FP has been analyzed in a thousand different ways in scientific literature, and FP languages tend to come with a semantics which is moreover effective for reasoning about programs. And I regard this as an advantage, because of the opportunity cost argument. But the "FP is more pure" (= natural) argument is bogus.</div>
 <div class="links">By <a href="user/742" title="View user profile.">Frank Atanassow</a> at Thu, 04/07/2005 - 12:44 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-5342"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5342" class="active">Myths and ideology in mathematics</a></h3>
 <div class="content"><blockquote>But mathematics is a cultural and historical artifact. I do not mean
that mathematical truths are relative </blockquote>

<p>This reminds me of <a
href="http://www.amazon.com/exec/obidos/ASIN/0521290384/"><em>Proofs and
Refutations</em></a> by <a href="http://en.wikipedia.org/wiki/Imre_Lakatos">Imre
Lakatos</a>, a highly influential work in philosophy of mathematics.  Since I
haven't reread it in more than five years, my recollection may be faulty.  (You
can double-check it by following the above Amazon link which gives you access to
the entire scanned book.)
</p>

<p>I believe Lakatos would strongly agree that <em>"mathematics is a cultural
and historical artifact"</em>.  I think he goes a little further and argues that
mathematical truths are, in fact, relative.  The above Wikipedia link gives a
fairly good summary of his views.</p>

<p>Here's a quote from the book found by searching "inside the book" for <a
href="http://www.amazon.com/gp/reader/0521290384/104-6880596-5765557?v=search-inside&keywords=absolute%20truth">absolute
truth</a>.  It's from the footnote that spans pages 54 and 55:</p>

<blockquote>'Nature confutes the sceptics, reason confutes the dogmatists'
(Pascal, [1659], pp. 1206-7).  Few mathematicians would confess [...] that
reason is too weak to justify itself.  Most of them adopt some brand of
dogmatism, historicism or confused pragmatism and remain curiously blind to its
untenability; for example. 'Mathematical truths are in fact <em>the prototype of
the completely incontestable</em>... But the rigor of maths is not absolute; it
is in a process of continual development; the <em>principles of maths have not
congealed once and for all</em> but have a life of their own and may even be the
subject of scientific quarrels.' (A.D.Aleksandrov [1956], p.7) (This quotation
may remind us that dialectic tries to account for change without using
criticism: truths are 'in continual development' but always 'completely
incontestable'.)
</blockquote>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Thu, 04/07/2005 - 15:41 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-5595"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5595" class="active">from Lakatos back to Hamming</a></h3>
 <div class="content"><p>On Apr 7, 2005, I wrote:</p>

<blockquote>This reminds me of Proofs and Refutations by Imre
Lakatos</blockquote>

<p>Interestingly, this brings us back to <a
href="http://en.wikipedia.org/wiki/Hamming">Hamming</a>.  I've been reading some
of the papers mentioned in a <a href="/node/view/646">recent new forum topic</a>
posted by <a href="/user/view/1139">Charles Stewart</a> on Apr 17, 2005.
Specifically, R.W. Hamming's essay <a href="/node/view/646#comment-5589"><em>The
Unreasonable Effectiveness of Mathematics</em></a> makes it clear that he was
deeply influenced by the aforementioned work of Imre Lakatos.
</p>

<p>A couple of quotes from the <a
href="http://www.lecb.ncifcrf.gov/~toms/Hamming.unreasonable.html">essay</a>:
</p>


<blockquote>
<p>It is claimed that an ex-editor of Mathematical Reviews once said that over
half of the new theorems published these days are essentially true though the
published proofs are false. How can this be if mathematics is the rigorous
deduction of theorems from assumed postulates and earlier results? Well, it is
obvious to anyone who is not blinded by authority that mathematics is not what
the elementary teachers said it was. It is clearly something else.</p>

<div>...</div>

<p>Indeed it seems to me: <strong>The Postulates of Mathematics Were Not on the
Stone Tablets that Moses Brought Down from Mt. Sinai.</strong></p>

<div>...</div>

<p>For over thirty years I have been making the remark that if you came into my
office and showed me a proof that Cauchy's theorem was false I would be very
interested, but I believe that in the final analysis we would alter the
assumptions until the theorem was true. Thus there are many results in
mathematics that are independent of the assumptions and the proof.
</p>

</blockquote>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Mon, 04/18/2005 - 18:32 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-5601"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5601" class="active">That reminds me</a></h3>
 <div class="content"><p >I had meant to respond to your earlier post.  I simply want to say, that anyone who hasn't read "Proofs and Refutations" should (even if you aren't particularly mathematically inclined).  It's enjoyable and quite good.</p></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Mon, 04/18/2005 - 20:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9571"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9571" class="active">Whose myth?</a></h3>
 <div class="content"><p >What's missing in Your analysis is that claiming that FP employs a completely "different way of thinking" is not a myth generated by the imperative crowd originally but by the FP crowd itself. What happend is turning an optimistic revolutionary attitude towards programming ( "forget everything you know about C .." or "you will have a hard time to unlearn but it will be worthwhile in the end .." [1] ) into a conservative and defensive reaction ( "you don't need a completely different way of thinking to get the job done .. "). The authors simply play back the ideological distinction to their originators. The message always arrives it's receiver.</p>
<p >Kay</p>
<p >[1] "Think different" is/was an optimistic slogan of Apple Corp. </p></div>
 <div class="links">By <a href="user/2128" title="View user profile.">Kay Schluehr</a> at Thu, 09/15/2005 - 09:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9888"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9888" class="active">And if it&#039;s recursion...</a></h3>
 <div class="content"><p >How can you be a good programmer if you think that recursion is a "new way of thinking"? Good programmers understand recursion, even if they write mostly for loops.</p></div>
 <div class="links">By <a href="user/2224" title="View user profile.">Nathan Sobo</a> at Thu, 09/22/2005 - 11:48 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5136"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5136" class="active">Nth languages</a></h3>
 <div class="content"><blockquote ><p >I should point out that, though I don't share that PL conservative outlook, I don't think it is unreasonable either. If you have spent many years mastering a particular "way of thinking about programming", you probably aren't going to want to give it up on short notice.</p></blockquote>
<p >I do find this somewhat unreasonable.  It should not take <i >years</i> for an experienced programmer to master or at the very least become proficient in a new programming language even if there is a paradigm shift. And as one learns more languages it takes even less time (and it takes even less time without a paradigm shift).  And it's not like you have to drop everything and hide away in a cave while you're learning.<br ><br ></p>
<p >Finally, this example alone is a pretty good example of why knowing multiple paradigms/languages is useful, and there are heaps of FP techniques being applied in OO languages nowadays providing another good incentive (at least for FP).  Learning other paradigms/languages is <i >not</i> a waste of time.<br ><br ></p>
<p >The Haskell code irks me; it is more verbose than it needs to be. I assume this was done to make it more recognizable to non-Haskell (read C++) programmers.</p>
<pre >
scale n = map (n*)
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys)
    | x == y    = x : merge xs ys
    | x <br ></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Wed, 03/30/2005 - 03:07 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5139"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5139" class="active">Unilingual Perquisites</a></h3>
 <div class="content"><p ><i >I do find this somewhat unreasonable. It should not take years for an experienced programmer to master or at the very least become proficient in a new programming language even if there is a paradigm shift.</i></p>
<p >How many years (decades) did it take OO to be understood by mainstream programmers?  Many still don't.</p>
<p >Just because some of us are good at this kind of thing shouldn't lead us to assume that most otherwise skilled  programmers should be too.</p>
<p >From a sociological point of view, I think you skipped over the pithier part of my post:</p>
<p ><i >No one wants to go from being a doctor or engineer in his "native" PL to being a taxi driver in someone else's.</i></p>
<p >The psychological benefits of sticking to what you know well are a pretty strong motivator.  </p>
<p >Like an English speaker in any part of the world where English is widely spoken as a second language, the path of least resistance is always to revert to English when the going gets rough.</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Wed, 03/30/2005 - 03:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5140"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5140" class="active">Professionalism</a></h3>
 <div class="content"><blockquote ><p >How many years (decades) did it take OO to be understood by mainstream programmers? Many still don't.</p></blockquote>
<p >I'm not talking about the mainstream, I'm talking about individuals, particularly professionals (more the connotations of the word rather than the denotation).</p>
<blockquote ><p >Just because some of us are good at this kind of thing shouldn't lead us to assume that most otherwise skilled programmers should be too.</p></blockquote>
<p >I have a feeling most people who are "good at this kind of thing" weren't born that way, have many languages under their belts, and found there first or second language took more time than the latter ones.  In a nutshell, they are "good at this" because they have practiced it!</p>
<blockquote ><p >No one wants to go from being a doctor or engineer in his "native" PL to being a taxi driver in someone else's.</p></blockquote>
<p >Part of my intent is that one isn't going to be a "taxi driver" for long.  Further, if such people are really so insecure, they can keep it to themselves until they feel comfortable.</p>
<blockquote ><p >The psychological benefits of sticking to what you know well are a pretty strong motivator.</p>
<p >Like an English speaker in any part of the world where English is widely spoken as a second language, the path of least resistance is always to revert to English when the going gets rough.</p></blockquote>
<p >Yep, this and the above are good reasons not to ever learn anything new at all!<br ><br ></p>
<p >I guess I should've stopped working at guitar, when I was feeling so clumsy trying to change chords smoothly or stopped drawing after circular filing some less-than-successful attempts, and there certainly were those CT papers that gave me a niced glazed look.  Sure, I wouldn't be able to play guitar, draw, or know what a colimit is now, but at least I wouldn't have felt uncomfortable!</p></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Wed, 03/30/2005 - 04:36 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5148"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5148" class="active">Pragmatism</a></h3>
 <div class="content"><p ><i >Yep, this and the above are good reasons not to ever learn anything new at all!</i></p>
<p >There is a difference between advocating a position and observing its power "on the ground".</p>
<p >If we want to advocate new ways of doing programming, we have to confront the reasons why they are resisted.</p>
<p >If we don't care if the benighted wallow in ignorance until their dying day, well, we could ignore them (and we wouldn't be discussing this article at all.)</p>
<p >It is easier to change people's behaviour than to change their values.  If we want them to adopt our favorite paradigm, we have to address the reasons they resist it.</p>
<p >If we don't care about that, we shouldn't get so mad that they resist it. ;-)</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Wed, 03/30/2005 - 14:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-5149"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5149" class="active">Just a thought about target audiences.</a></h3>
 <div class="content"><p >Wonders whether teaching any subject, requires the decision of whether to teach to the bottom, middle, or top of the class.  Those that teach to the top are accused of elitism.  Those that teach to the bottom are accused of dumbing down.  And those that teach to the middle are accused of promoting mediocrity.</p>
<p >[edit note: And I'd prefer LtU to be accessible to all three at the same time]</p>
<p >[edit edit note:  Ok, so we might not want the absolute dregs]  :-)</p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Wed, 03/30/2005 - 14:29 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-5154"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5154" class="active">Different Class</a></h3>
 <div class="content"><p>Not only that, but some of us are sitting in the Advanced Category Theory seminar while others are attending Object Oriented Programming With Java 101.</p>
<p>I personally want to see some Ruby-on-Rails-style tutorials for web programming with Haskell...</p></div>
 <div class="links">By <a href="user/813" title="View user profile.">Dominic Fox</a> at Wed, 03/30/2005 - 16:29 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-5155"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5155" class="active">Old school</a></h3>
 <div class="content"><p >Being one who's mid-tier but hangs around smart people hoping some of that knowledge will rub off, I think it's important for the best and brightest to reach down (as well as up).  It helps to touch bases with the basics periodically to help solidify the more abstract ideas (a dose of reality) and helps bring in new aspirants to mix up the field of ideas.</p>
<p >Of course, the alternative is to put the Oleg's and Noel's in a room by themselves, but they'd probably get bored with each other sooner or later.  :-)</p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Wed, 03/30/2005 - 17:19 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:200px;">
<a id="comment-5156"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5156" class="active">My approach</a></h3>
 <div class="content"><p >Or you create a community site like LtU, where demi-gods can share their wisdom... I really suggest people use this opportunity (e.g., Oleg's paper about delimited continuations currently being discussed).</p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Wed, 03/30/2005 - 17:30 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5143"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5143" class="active">Conciseness</a></h3>
 <div class="content"><blockquote ><p >
The Haskell code irks me; it is more verbose than it needs to be.
</p></blockquote>
<p >Perhaps then you should also drop the matches on nil in merge.</p>
<pre >scale n = map (n*)
merge (x:xs) (y:ys)
    | x == y    = x : merge xs ys
    | x &lt;  y    = x : merge xs (y:ys)
    | otherwise = y : merge (x:xs) ys

seq = 1 : merge (scale 2 seq)
                (merge (scale 3 seq) (scale 5 seq))
</pre><br ></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Wed, 03/30/2005 - 08:46 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5146"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5146" class="active">Ironic</a></h3>
 <div class="content"><p >The irony is that the original definition of scale will only work on infinite lists whereas my version will work on finite or infinite lists, however the original version of merge would work on finite lists, but this version won't.  It's a bit of an odd inconsistency in the original code.</p></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Wed, 03/30/2005 - 13:02 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5147"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5147" class="active">IMHO the version of each func</a></h3>
 <div class="content"><p >IMHO the version of each function that works on finite lists is to be preferred, simply because that is least surprising. That said, a comment that as all lists inside the programme are infinite, termination conditions are not needed would probably remove the element of surprise.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Wed, 03/30/2005 - 14:07 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5114"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5114" class="active">Apples to oranges</a></h3>
 <div class="content"><p >The Haskell implementation is complete self-contained solution.  It requires no reference to libraries.  The C++ is simply leveraging off behavior provided by the template library.  In terms of simplicity, the haskell solution just requires you learn that languages syntax, of which this example is a pretty plain jane example.  For the C++, you have to learn it's immense syntax, figure out how it's used here, and then dive into the template library and figure out what to do there.  And we are talking about a math problem here.</p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Tue, 03/29/2005 - 16:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5116"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5116" class="active">Default Assumptions</a></h3>
 <div class="content"><p >Chris Rathman: <i > For the C++, you have to learn it's immense syntax, figure out how it's used here, and then dive into the template library and figure out what to do there.</i></p>
<p >I think Koenig and Moo's assumption is that a modern C++ programmer has done that, and therefore there won't be any mystery to their C++ solution, whereas even once you explain the Haskell syntax, the approach of pattern matching on algebraic data structures is still alien.</p>
<p >Of course, you still have a point; it's not the least bit alien to anyone conversant in any of the ML family, Haskell, Oz, Concurrent Clean...</p>
<p >The topic is a pertinent one to me. As I've written before, my day job involves a large-ish body of C++ written aggressively in the Microsoft MFC style, and I'm slowly attempting to untangle it and make it more idiomatic in the context of what it does. Since a lot of what it does is deal with containers, moving more to functionalism and the use of exceptions feels very natural to me, but folks who don't know the STL and boost::bind reasonably well find some of my code weird. So even within the C++ community, there's a knowledge/stylistic-preference gap that has to be addressed.</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Tue, 03/29/2005 - 16:50 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5176"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5176" class="active">Wrong assumptions</a></h3>
 <div class="content"><p >One of the first languages I looked at after C and Java was OCaml (I read part of SICP before).  Pattern matching algebraic data structures was the most natural thing.  I immediately started hating C dialects for the (needless) lack thereof.</p>
<p >Often ML code is clearer than the infinitely tangled data and control flow that usually ends up in any non-trivial Java program, with all kinds of objects calling each other.  No wonder that often a bug ends up somewhere inbetween!</p>
<p >That said, I like imperative features.</p></div>
 <div class="links">By <a href="user/1498" title="View user profile.">Ulrich Hobelmann</a> at Thu, 03/31/2005 - 19:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5119"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5119" class="active">&quot;Language&quot; vs &quot;Library&quot; is often an artificial distinction.</a></h3>
 <div class="content"><p >Does it matter much that lists in ML are an "intrinsic" datatype, whereas std::set is part of the library (and is capable itself of being written in "plain" C++)?  In my mind, no.</p>
<p >There are many good arguments to use in language flamewars; the language-vs-library argument isn't one of them.  After all, if C++ had sets as an intrinsic datatype, that would just be further grist for the "it's a bloated langauge" mill.  :)</p>
<p >Any competent C++ programmer should be familiar with the STL.  That said, there are many who aren't--who still use it as little more than an OO extension to C.  </p></div>
 <div class="links">By <a href="user/176" title="View user profile.">Scott Johnson</a> at Tue, 03/29/2005 - 18:01 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5126"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5126" class="active">It&#039;s a question of the amount of information conveyed</a></h3>
 <div class="content"><p >The Haskell example captures the abstraction in very large part.  The C++ example shows a recipe for using the library to create a solution.  There is an impedance mismatch between the depth of information the Haskell code conveys and what the C++ code conveys - being at once both a higher and a lower level of abstraction for the Haskell code.</p>
<p >Sure, libraries level the playing field.  For 99.99% of the population that uses such things, the example given will just be a recipe to be copied and pasted.  Either solution could be put in a library and added to the next generation of HQ9++ as a single character N (H is already taken).</p>
<p ><cite >The traditional mathematician recognizes and appreciates mathematical elegance when he sees it. I propose to go one step further, and to consider elegance an essential ingredient of mathematics: if it is clumsy, it is not mathematics.<br >
- Edsger Dijkstra</cite></p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Tue, 03/29/2005 - 19:42 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5177"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5177" class="active">Lists in ML; C++ templates</a></h3>
 <div class="content"><p >aren't part of the language.  They are pattern-matched like everything else.</p>
<p >Lists in ML, just like strings in Java, have an extra built-in syntax, though, because their use is so common.</p>
<p >To C++: the best features of that language are that is makes some common C idioms easier, adds some typechecking and gives inheritance (which is overused, though).</p>
<p >OTOH, I still use C in preference, since C++'s assumptions to memory layout (variable sized structs aren't really possible as classes) are restrictive.  Templates are the worst thing since unsliced bread, requiring everything the code to be compiled for EVERY freaking instantiation!  In C I just put a void pointer in a structure, no need to compiled it 50 times.  I don't use the STL&amp;C++ for that reason.</p></div>
 <div class="links">By <a href="user/1498" title="View user profile.">Ulrich Hobelmann</a> at Thu, 03/31/2005 - 19:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5133"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5133" class="active">Builtin syntax vs. standard library? Doesn&#039;t matter</a></h3>
 <div class="content"><p >Regarding the simplicity of a program, it doesn't matter which part of the language it uses is built into the language and which is a part of the standard library.</p>
<p >Actually if more is done in a library then it's a sign of a more flexible language. Since libraries can be added but compilers cannot be easily extended, it means that a random other problem has a higher chance of admitting a clean solution: even if it wasn't considered by language designers, it can be solved by library writers later.</p>
<p >If you say that it's unfair because it makes languages with lots of libraries appear more powerful than those without, then I reply that they appear more powerful because they are. Libraries matter.</p>
<p >A ready library might be less universal than the ability to implement a solution from scratch, but it definitely allows the task to be solved much easier when it applies.</p></div>
 <div class="links">By <a href="user/1547" title="View user profile.">Qrczak</a> at Tue, 03/29/2005 - 22:37 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5134"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5134" class="active">Sign of a flexible language?</a></h3>
 <div class="content"><blockquote ><p ></i>Actually if more is done in a library then it's a sign of a more flexible language.</i></blockquote>
The argument would hold more weight had the template library not required the C++ compiler to be majorly modified to get them to work.<br ><br ></p>
<p >More generally though, there are lots of smart programmers out there who can make libraries out of even the worst languages.  The availability of libraries has much less to do with the quality of the<br >
language and more to do with the shear numbers of people using the language to various ends.<br ><br ></p>
<p >Anyhow, my argument isn't about how simple it is to do this in C++ vs. Haskell.  It's about the mismatch between the code samples.  The C++ code has much of the detail hiding behind the library whereas the Haskell code is just fairly straight forward from that languages perspective.  And just because the sample Haskell code does not use a library doesn't mean that it couldn't be implemented as a library for sequences.<br ><br ></p>
<p >There are a lot of things which are simpler in C++ but I fancy that infinite algebraic series is not among the top.<br ></p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Tue, 03/29/2005 - 23:28 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5158"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5158" class="active">Of course... a language should support some basic set</a></h3>
 <div class="content"><p >of features.  </p>
<p >You mention C++ templates (more generically, generic polymorphism).  You are correct; implementing the STL--or anything like it--required this feature be present in the language; Java is now undergoing a similar evolution. </p>
<p >No argument there.</p>
<p >And as others have pointed out, the advantage that Haskell has over C++ in this instance is lazy evaluation and lazy data structures.  One could port the Haskell algorithm (and it's O(n) performance) to C++, but the code would be an ugly hodgepodge of roll-your-own thunks and other assorted hackery, needed to emulate lazy evaluation in an otherwise eager language.  (Think of a Scheme implementation of the same algorithm, then convert the uses of delay/force one would find into equivalent C++ machinery).</p>
<p >However, comparisons of the C++ and Haskell code above are comparing apples to oranges; they are <i >different algorithms</i>.  One uses lazy evaluation of lists to select elements from an ever-expanding "frontier" of possible choices; the other uses an ordered associative container (a STL "set") to essentially sort the elements.  The behavior of std::set is well-known to any C++ programmer (including performance characteristics, which are documented), and the meaning of the above code fragment is clear as day.  Just as the meaning of the Haskell snippet is obvious to a competent Haskell programmer.  Both samples are likely to be difficult to read for someone not conversant in the language.</p>
<p >Regarding "hiding detail"--where I come from, that's considered a <i >good</i> thing.  I don't want to know (or care) that std::set is implemented using a red/black tree, for instance... such details are not germaine to the problem at hand.  What salient detail did you think the C++ code obscured?</p></div>
 <div class="links">By <a href="user/176" title="View user profile.">Scott Johnson</a> at Wed, 03/30/2005 - 17:42 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5161"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5161" class="active">Guess I could be defensive to the bitter end</a></h3>
 <div class="content"><p >Of such intransigence are language wars made of.  But I'll bow out under the premise that I glean more information from the Haskell code than the C++ code - and yes that could very well be because I've been working more with Hindley-Milner type systems of late and haven't worked much with C++ Templates.  </p>
<p >But as you state, they are different algorithms, so I win my argument anyhow, even if I had to totally change my argument in the process.  :-)</p></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Wed, 03/30/2005 - 18:18 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5121"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5121" class="active">totally different?</a></h3>
 <div class="content"><p>Where the article presents "The Functional Solution" it is quite reasonable, introducing lazy lists gently, and ending with "[the definition of seq] is no more magical than our earlier example".  The comment about a "totally different way of thinking" is not supported in the article, but it's surely intended to set up the C++ solution as preferable. Of course, it's the FP advocates who continually assert the difference.</p>
<p>The primary difference in the functional program is that it has a name for the infinite list that <em>is</em> the solution.  The alternatives provide a data structure where the solution is accumulated, which to my eyes appears unfinished.
The "idiomatic" solution <em>generates</em> the numbers OK, but does not provide an idiomatic way to <em>access</em> them, i.e. via an iterator.
The article's conclusion is flawed, since its solution amounts to a fair demonstration of a hole in C++'s expressivity.</p>
</div>
 <div class="links">By <a href="user/336" title="View user profile.">Scott Turner</a> at Tue, 03/29/2005 - 18:30 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-5122"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5122" class="active">Full C++ listing please</a></h3>
 <div class="content"><p >What is the full C++ listing? The C++ listing given assembles an ordered set containing the numbers 1,2,3,5.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 03/29/2005 - 18:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5123"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5123" class="active">for the reader to complete</a></h3>
 <div class="content"><p >The OP contains all of the code from the article, and <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a> doesn't have it yet. (And if you guess the name of the zip file for the April code, the code from the Koenig/Moo article isn't in that file, either.)</p></div>
 <div class="links">By <a href="user/336" title="View user profile.">Scott Turner</a> at Tue, 03/29/2005 - 18:48 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5124"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5124" class="active">OP?</a></h3>
 <div class="content"><p >OP?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 03/29/2005 - 19:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5125"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5125" class="active">OP?</a></h3>
 <div class="content"><p >original post/poster [in the thread]</p></div>
 <div class="links">By <a href="user/336" title="View user profile.">Scott Turner</a> at Tue, 03/29/2005 - 19:23 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5127"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5127" class="active">An attempt at a full C++ version</a></h3>
 <div class="content">Below is an attempt at a full C++ version. It differs from the haskell version at the 38th number. 
<p>
(edit) Initially I was confused as to why this is; I've realised that this is because of the order in which the numbers are produced. Increasing the 20 to 60, for example, causes the lists to agree in the 38th number. One might suggest that the haskell version has comprehensibility benefits.
<pre>
#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
{
   set&lt;int&gt; seq;
   seq.insert(1);
   set&lt;int&gt;::const_iterator it = seq.begin();

   for(int i = 0; i < 20; ++i)
   {
      int val = *it;
      seq.insert(val * 2);
      seq.insert(val * 3);
      seq.insert(val * 5);
      it++;
   }

   it = seq.begin();
   std::cout << *(it++);
   for(; it != seq.end(); ++it)
      std::cout << "," <<  *it;
   std::cout << std::endl;
   return 0;
}
</pre></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 03/29/2005 - 19:44 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5129"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5129" class="active">a deficiency in the C++ implementation</a></h3>
 <div class="content"><blockquote>It differs from the haskell version at the 38th number. Anyone have
an idea why?</blockquote>

<p>Because you haven't computed the 38th number yet. You execute the body of the loop 20 times, generating 
the following 41 numbers:</p>

<pre>
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45,
48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 135, 150, 160,
180
</pre>

<p>135 is (incorrectly) followed by 150.</p>

<p>If you iterate 30 times &mdash; instead of 20 &mdash; your program generates
the following 56 numbers:
</p>

<pre>
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45,
48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144,
150, 160, 162, 180, 192, 200, 216, 225, 240, 250, 270, 300, 320, 360, 375, 400
</pre>

<p>135 is now (correctly) followed by 144.</p>

<p>So, I think your example highlights a deficiency in the "idiomatic C++"
implementation.  There is no easy way to tell how many insertions one needs to
perform in order to compute the <em>N</em>th Hamming number correctly.  Thanks
for pointing this out.
</p>


<p>P.S. I found this on the python list: <a
href="http://mail.python.org/pipermail/python-list/2005-January/262002.html">Classical
FP problem in python : Hamming problem</a> (alternatively, see the <a
href="http://mail.python.org/pipermail/python-list/2005-January/thread.html#262002">entire
thread</a>)
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 03/29/2005 - 20:25 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5141"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5141" class="active">I can&#039;t believe I wrote this...</a></h3>
 <div class="content"><blockquote><i>There is no easy way to tell how many insertions one needs to perform in order to compute the Nth Hamming number correctly.</i></blockquote>
<p>On the other hand, by simply iterating N times, you do at most O(1) too much (amortised) work.</p>
<p>This suggests the following implementation, which is a little closer to the Haskell version.  Plus, it's about as short as the original C++ version if you ignore includes and typedefs.</p>
<pre>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;boost/iterator/transform_iterator.hpp&gt;

using namespace std;
using namespace boost;

typedef binder1st&lt;multiplies&lt;int&gt; &gt; scale_type;
typedef transform_iterator&lt;scale_type, set&lt;int&gt;::iterator&gt; scale_iterator;

main()
{
    set&lt;int&gt; s;
    s.insert(1);

    scale_iterator it2(s.begin(), bind1st(multiplies&lt;int&gt;(), 2));
    scale_iterator it3(s.begin(), bind1st(multiplies&lt;int&gt;(), 3));
    scale_iterator it5(s.begin(), bind1st(multiplies&lt;int&gt;(), 5));
    set&lt;int&gt;::iterator it = s.begin();

    for (int i = 0; i &lt; 40; ++i)
    {
	s.insert(*it2++);
	s.insert(*it3++);
	s.insert(*it5++);
	if (i &gt; 0) { std::cout &lt;&lt; ", "; }
	std::cout &lt;&lt; *it++;
    }
    std::cout &lt;&lt; '\n';
}
</pre>
<p>This is <i>almost</i> the Haskell version.  To do the Haskell version properly, and have constant time access, you need to implement merge.  Here are the gory details, courtesy of Boost.  Don't read if you're squeamish...</p>
<pre>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;boost/iterator/transform_iterator.hpp&gt;
#include &lt;boost/iterator/iterator_facade.hpp&gt;

using namespace std;
using namespace boost;

typedef binder1st&lt;multiplies&lt;int&gt; &gt; scale_type;
typedef transform_iterator&lt;scale_type, list&lt;int&gt;::iterator&gt; scale_iterator;

template&lt;typename It1, typename It2&gt;
class merge_iterator
    : public boost::iterator_facade&lt;
	      merge_iterator&lt;It1, It2&gt;
	    , const int
	    , incrementable_traversal_tag
	&gt;
{
public:
    merge_iterator(It1 p_it1, It2 p_it2)
	: m_it1(p_it1), m_it2(p_it2)
    {
    }

private:
    friend class iterator_core_access;

    void increment()
    {
	int x1 = *m_it1;
	int x2 = *m_it2;
	if (x1 &lt;= x2) { ++m_it1; }
	if (x1 &gt;= x2) { ++m_it2; }
    }

    const int& dereference() const
    {
	return std::min(*m_it1, *m_it2);
    }

    It1 m_it1;
    It2 m_it2;
};

main()
{
    list&lt;int&gt; s;
    s.push_back(1);

    std::cout &lt;&lt; 1;

    scale_iterator it2(s.begin(), bind1st(multiplies&lt;int&gt;(), 2));
    scale_iterator it3(s.begin(), bind1st(multiplies&lt;int&gt;(), 3));
    scale_iterator it5(s.begin(), bind1st(multiplies&lt;int&gt;(), 5));
    merge_iterator&lt;scale_iterator,
	           merge_iterator&lt;scale_iterator, scale_iterator&gt; &gt;
	    it(it2, merge_iterator&lt;scale_iterator, scale_iterator&gt;(it3, it5));

    for (int i = 1; i &lt; 40; ++i, ++it)
    {
	int x = *it;
	std::cout &lt;&lt; ", " &lt;&lt; x;
	s.push_back(x);
    }
    std::cout &lt;&lt; '\n';
}
</pre>
<p>It's a lot less ugly than I thought it would be.</p>
<p>Interestingly, the hardest part that I found was getting the typedefs and other type declarations right.  The actual code was easy.  Especially since I ignored termination conditions on the input iterators.</p>
<p>One thing which isn't covered here, of course, is that the Hamming number problem is a very artificial problem in the first place.</p></div>
 <div class="links">By <a href="user/1053" title="View user profile.">Pseudonym</a> at Wed, 03/30/2005 - 05:24 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5145"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5145" class="active">I note that the &quot;full haskell</a></h3>
 <div class="content"><p >I note that the "full haskell C++" version does require a lot more boilerplate and declaration than the haskell version, which does rather obscure its meaning, at least at first glance. The same is not true of the "semi-haskell" version I feel, which is probably clearer than either of my versions.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Wed, 03/30/2005 - 11:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5166"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5166" class="active">To be fair...</a></h3>
 <div class="content"><p>It's true that the "full Haskell C++" version has more boilerplate, but in fairness, I used a pile driver to crack an egg: <tt>hamming_iterator</tt> is a fully conforming proposed-standard iterator, which is arguably overkill.</p>
<p>In writing it, I found that the declarations were the most tricky parts.  The boilerplate (and it's not clear that it's <i>all</i> boilerplate; it's there because C++ iterators can do things that Haskell lazy lists can't, such as allow clients to modify what they point to if the container allows it) was fairly mechanical, didn't take long, and worked first time more or less.</p>
<p>I agree with Scott Turner that I'd rather do a recreational programming problem like this in Haskell.  On the other hand, I learned stuff doing it this way in C++.</p>
<p>I think the most disturbing remark in the original article is that the Haskell solution "requires a totally different way of thinking about programming".  If you're a professional software engineer on a deadline, and you can see a solution that's easy for you to understand and good enough, then you should do it.  Your time is valuable.</p>
<p>In this case, though, we're talking about Hamming numbers.  Why you would bother with such a simple, artificial, recreational programming problem if you <i>weren't</i> trying to learn something?</p></div>
 <div class="links">By <a href="user/1053" title="View user profile.">Pseudonym</a> at Thu, 03/31/2005 - 05:31 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5160"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5160" class="active">C++ still not comparable to Haskell</a></h3>
 <div class="content"><p>That matches the efficiency of the Haskell, but not the expressiveness.  The Haskell version has a name <code>'seq'</code> which embodies the infinite sequence of Hamming numbers. Very straightforward.  In C++ that should be represented by an iterator. In the above programs, neither <code>s.begin()</code> nor <code>'it'</code> is the complete answer.</p>
<p>Below is the implementation an iterator class <code>hamming</code> which represents the infinite sequence of numbers.</p>
<pre>
[includes and typedefs just like "almost Haskell" version above]

set&lt;int&gt; set_of_one () {
    set&lt;int&gt; s;
    s.insert(1);
    return s;
}

class hamming
    : public boost::iterator_facade&lt;
	      hamming
	    , const int
	    , incrementable_traversal_tag
	&gt;
{
public:
    hamming ()
      : s(set_of_one()),
	it2(s.begin(), bind1st(multiplies&lt;int&gt;(), 2)),
        it3(s.begin(), bind1st(multiplies&lt;int&gt;(), 3)),
        it5(s.begin(), bind1st(multiplies&lt;int&gt;(), 5))
    {
    	it = s.begin();
    }

private:
    friend class iterator_core_access;

    void increment()
    {
        s.insert(*it2); it2++; // Fix bug affecting the first increment.
	s.insert(*it3++);
	s.insert(*it5++);
	it++;
    }

    const int&amp; dereference() const
    {
        return *it;
    }

    set&lt;int&gt; s;
    set&lt;int&gt;::iterator it;
    scale_iterator it2;
    scale_iterator it3;
    scale_iterator it5;
};
</pre>
<p>Fixing the bug in the "almost Haskell" version, and figuring out a way to initialize everything was a firm reminder of why I do my recreational programming in Haskell. It's not just that the C++ version is more verbose; it's more complex and error-prone. A class like <code>hamming</code> can be useful, and "a whole new way of thinking" is not necessary to understand that. Agreed, the problem is not routine, but it remains a good example of the merits of FP.</p></div>
 <div class="links">By <a href="user/336" title="View user profile.">Scott Turner</a> at Wed, 03/30/2005 - 18:01 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5180"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5180" class="active">One small thing...</a></h3>
 <div class="content"><p>I carefully used <tt>list</tt> rather than <tt>set</tt> in my "full Haskell" version.  The difference is O(n log n) vs O(n) time.</p></div>
 <div class="links">By <a href="user/1053" title="View user profile.">Pseudonym</a> at Fri, 04/01/2005 - 00:40 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5130"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5130" class="active">Another modification</a></h3>
 <div class="content"><p >I should mention that the following version behaves slightly more intuitively:</p>
<pre >
#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
{
   set&lt;int&gt; seq;
   seq.insert(1);
   set&lt;int&gt;::const_iterator it = seq.begin();

   for(int i = 0; i ::const_iterator it2 = seq.begin();
   std::cout <br ></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 03/29/2005 - 21:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5131"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5131" class="active">python version</a></h3>
 <div class="content"><blockquote>I should mention that the following version behaves slightly more
intuitively: </blockquote>

<p>Right, we end up generating an ordered set of 72 numbers (1, 2, ..., 675,
720) of which only the first 40 can be trivially proven to be consecutive
Hamming numbers.  The rest of the sequence contains gaps.
</p>

<p>For archival purposes, here's the Python version:</p>

<pre>
# http://mail.python.org/pipermail/python-list/2005-January/262118.html
# http://mail.python.org/pipermail/python-list/2005-January/262277.html
# http://mail.python.org/pipermail/python-list/2005-January/262292.html

# Requires Python 2.4

from itertools import tee, imap

def imerge(xs, ys):
    x = xs.next()
    y = ys.next()
    while True:
        if x == y:
            yield x
            x = xs.next()
            y = ys.next()
        elif x < y:
            yield x
            x = xs.next()
        else:
            yield y
            y = ys.next()


def hamming():
    def _hamming():
        yield 1
        for n in imerge(imap(lambda h: 2*h, hamming2),
                        imerge(imap(lambda h: 3*h, hamming3),
                               imap(lambda h: 5*h, hamming5))):
            yield n
    hamming2, hamming3, hamming5, result = tee(_hamming(), 4)
    return result

for i in hamming():
    print i,
</pre>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 03/29/2005 - 22:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5132"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5132" class="active">The version you replied to pr</a></h3>
 <div class="content"><p >The version you replied to printed out the first 40 hamming numbers correctly. Replacing 40 in the programme with n would result in the first n hamming numbers being printed. For the record, I guessed that the modification would rectify the problem, rather than reasoning about the programme.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 03/29/2005 - 22:12 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5135"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5135" class="active">zerg</a></h3>
 <div class="content"><blockquote><p>I may be reading too much into this quote, but it sounds to me like Koenig and Moo consider it a bad thing to require a "totally different way of thinking about programming".</p></blockquote>  <p>In my Programming Paradigms & Foundations class w/ Dr. Koenig, so far we've covered Algol, Smalltalk, Icon, APL and Simula.  We've tried as much as possible to compare language features to Java, C++, Scheme and Python.  We've talked about Djikstra's structured programming and next week we will talk about John Backus' "Can Programming Be Liberated from the von Neumann Style?"</p>

<p>In no way at any time have I gotten the impression that he would think that "a totally different way of thinking about programming" would be a bad thing.  This includes the first lecture, which was more or less the article he & his wife published in the 2005 April CUJ.</p></div>
 <div class="links">By <a href="user/1761" title="View user profile.">Capt. Jean-Luc Pikachu</a> at Wed, 03/30/2005 - 01:50 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5137"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5137" class="active">Dodo-egg Omelette</a></h3>
 <div class="content"><p ><i >Algol, Smalltalk, Icon, APL and Simula... Java, C++, Scheme and Python</i></p>
<p >Pardon me for being underwhelmed; only one unambiguously FP language in the bunch, and heavily weighted to PLs that predate C++ (and which thereby could have had their features co-opted or rejected during the development of C++.)</p>
<p >Everybody thinks they're open-minded; they just have a few things they think are too weird to consider seriously.  ;-) </p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Wed, 03/30/2005 - 03:14 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5138"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5138" class="active">Well, I believe he has used A</a></h3>
 <div class="content"><p>Well, I believe he has used Algol & APL during his work @ AT&T, but I see what you're saying.  Still, I'm not convinced that he's outright rejected functional programming and I don't see his article as a warning to stay away from FP...  After all, it is called C/C++ Users Journal, and not Haskell Users Journal...</p>
<p>w/ respect to your post's title, I believe you will only pry Squeak from its users' cold, dead hands.  :P  Also, I'm pretty sure Icon is where Python got its generators from (I've been wrong about this sort of thing before).</p>
<p>(Is there such a thing as HUJ?)</p></div>
 <div class="links">By <a href="user/1761" title="View user profile.">Capt. Jean-Luc Pikachu</a> at Wed, 03/30/2005 - 03:28 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5144"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5144" class="active">Generators</a></h3>
 <div class="content">Also, I'm pretty sure Icon is where Python got its generators from<br >
&gt; (I've been wrong about this sort of thing before)</p>
<p >You're certainly OK on this point. It should be noted though that while the concept of generators from Icon made it into Python (largely I believe due to Tim Peters), the way in which generators integrate into the language is entirely different. Icon's underlying expression language is massively different to Python's, and generators are a natural fit into Icon, whereas in Python they're rather restricted. Some well known Icon people <a href="http://www.mail-archive.com/unicon-group@lists.sourceforge.net/msg00616.html">feel that Python's generators don't compare to Icon's</a> and I think they have a point.</p></div>
 <div class="links">By <a href="user/1322" title="View user profile.">Laurence Tratt</a> at Wed, 03/30/2005 - 09:00 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5157"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5157" class="active">Koenig and FP</a></h3>
 <div class="content"><p >For what it is worth:</p>
<p >"In his 35+ years as a programmer, Andrew Koenig has written an online student registration system in APL, a software distribution system in a mixture of C and C++, pattern matching libraries in C++, ML..."</p>
<p >Bio Quote taken from http://www.artima.com/weblogs/viewpost.jsp?thread=54469</p>
<p >Perhaps of more interest:<br >
"An anecdote about ML type inference" By Andrew Koenig<br >
http://www.usenix.org/publications/library/proceedings/vhll/full_papers/koenig.a</p></div>
 <div class="links">By <a href="user/113" title="View user profile.">Todd Coram</a> at Wed, 03/30/2005 - 17:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5179"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5179" class="active">Logic paradigm solution for Hamming numbers</a></h3>
 <div class="content"><code style="font-size:120%;font-style:normal;">
<br>
<br>
stratify hamming(N) by [N,hamming].<br>
stratify print(N)   by [N,print].<br>
stratify hamming << print.<br>
hamming(1).<br>
hamming(New) <-- hamming(Old), New is Old*2, New < 100000.<br>
hamming(New) <-- hamming(Old), New is Old*3, New < 100000.<br>
hamming(New) <-- hamming(Old), New is Old*5, New < 100000.<br>
print(Num)   <-- hamming(Num).<br>
<br>
<br>
</code>

<p>
via <a href="http://www.cs.waikato.ac.nz/Research/starlog/">Starlog</a>.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Thu, 03/31/2005 - 21:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5192"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5192" class="active">a Prolog solution</a></h3>
 <div class="content"><p>The Starlog solution looks much neater than, 
say,</p>

<pre>
/*
  http://lml.ls.fi.upm.es/~jjmoreno/jjpapers/expr_imp.ps
*/

generate(dif(Twos, [V2|L2]), dif(Threes, [V3|L3]), dif(Fives, [V5|L5])) :-
        select(Twos, Threes, Fives, V),
        dequeue(Twos, Twos1, V),
        dequeue(Threes, Threes1, V),
        dequeue(Fives, Fives1, V),
        V2 is 2*V,
        V3 is 3*V,
        V5 is 5*V,
        write(V),  nl,
        generate(dif(Twos1, L2), dif(Threes1, L3), dif(Fives1, L5)).

select([X1|_L1], [X2|_L2], [X3|_L3], X1) :- X1 =&lt; X2, X1 =&lt; X3.
select([X1|_L1], [X2|_L2], [X3|_L3], X2) :- X2 &lt; X1, X2 =&lt; X3.
select([X1|_L1], [X2|_L2], [X3|_L3], X3) :- X3 &lt; X1, X3 &lt; X2.

dequeue([X|L], L, X).
dequeue([Y|L], [Y|L], X) :- X \= Y.

hamming :- generate(dif([1|L2], L2), dif([1|L3], L3), dif([1|L5], L5)).
</pre>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Fri, 04/01/2005 - 13:59 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5181"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5181" class="active">Remarkably concise Haskell function</a></h3>
 <div class="content"><pre style="font-size:120%;font-style:normal;">
hamming = 1 : map (*2) hamming # map (*3) hamming # map (*5) hamming
    where xxs@(x:xs) # yys@(y:ys)
              | x==y = x : xs#ys
              | x&lt;y  = x : xs#yys
              | x&gt;y  = y : xxs#ys
</pre>

<p>
via <a href="http://www.answers.com/topic/haskell-programming-language">Answers.com</a>.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Fri, 04/01/2005 - 03:24 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5193"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5193" class="active">Number signs?</a></h3>
 <div class="content"><p ><i >xs#ys</i></p>
<p >Are those number signs supposed to be "++"?</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Fri, 04/01/2005 - 14:18 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5198"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5198" class="active">Local infix operator # (merge)</a></h3>
 <div class="content"><p >No, # is the infix operator that's defined as a local function in hamming's where clause.</p></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Fri, 04/01/2005 - 16:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5200"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5200" class="active">Back to drawing board</a></h3>
 <div class="content"><p ><i >No, # is the infix operator that's defined as a local function in hamming's where clause.</i></p>
<p >Ah, obvious now that you point it out.</p>
<p >I guess I either have to go back to the drawing board with Haskell, or that code was a bit TOO concise for my own good. ;-)</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Fri, 04/01/2005 - 17:14 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5201"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5201" class="active">Space Complexity</a></h3>
 <div class="content"><p >Has anyone done a space complexity analysis of the Haskell program? </p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Fri, 04/01/2005 - 17:21 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5204"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5204" class="active">Re: Space Complexity</a></h3>
 <div class="content"><p>I think it's fair to ask the same question of the C++ implementation.</p>

<p>In the Haskell case, you need to "remember" (some of) the previously computed
numbers.  To be more precise, to compute the <em>N</em>th Hamming number
<em>H<sub>N</sub></em>, you need to remember the previously computed numbers in
the interval of [<em>H<sub>N</sub> / 5</em>, <em>H<sub>N</sub></em>].
</p>

<p>In the C++ case, you end up carrying around all of the numbers in the
interval of [1, <em>H<sub>N</sub></em>] plus "most" of the numbers in the
interval of [<em>H<sub>N</sub></em>, 5*<em>H<sub>N</sub></em>].</p>

<p>Since I don't have the required number-theoretical skills to estimate the
sizes of the aforementioned sequence intervals, I ran a quick numeric experiment
instead.  The following listing shows the first 12 Hamming numbers.  The blue
lines show the sequence that the Haskell implementation must "remember" at each
step.  The red lines show the set of numbers computed by the K &amp; M's <a
href="/node/view/608#comment-5130">C++ implementation</a> at each step.  To keep
the sequences visually aligned, I use underscores to show the current gaps in
the C++ ordered set.  These show the positions of currently missing Hamming
numbers that will be filled at some later point.
</p>

<p>In the Haskell case, I use the following conventions to indicate the current
end of the "scaled" lazy lists:</p>

<ul>
  <li>the underlined number is the end of the list scaled by 2;</li>
  <li>the bold number is the end of the list scaled by 3;</li>
  <li>the crossed-out number is the end of the list scaled by 5.</li>
</ul>


<pre>
<span style="color: Blue"><span style="text-decoration: line-through"><strong><span style="text-decoration: underline">1</span></strong></span></span>
<span style="color: FireBrick">1 2 3 _ 5</span>

<span style="color: Blue"><span style="text-decoration: line-through"><strong>1</strong></span> <span style="text-decoration: underline">2</span></span>
<span style="color: FireBrick">1 2 3 4 5 6 _ _ 10</span>

<span style="color: Blue"><span style="text-decoration: line-through">1</span> <strong><span style="text-decoration: underline">2</span></strong> 3</span>
<span style="color: FireBrick">1 2 3 4 5 6 _ 9 10 __ 15</span>

<span style="color: Blue"><span style="text-decoration: line-through">1</span> <strong>2</strong> <span style="text-decoration: underline">3</span> 4</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 __ __ 20</span>

<span style="color: Blue">  <span style="text-decoration: line-through"><strong>2</strong></span> <span style="text-decoration: underline">3</span> 4 5</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 __ __ 20 __ 25</span>

<span style="color: Blue">  <span style="text-decoration: line-through">2</span> <strong>3</strong> <span style="text-decoration: underline">4</span> 5 6</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 __ 18 20 __ 25 __ 30</span>

<span style="color: Blue">  <span style="text-decoration: line-through">2</span> <strong>3</strong> 4 <span style="text-decoration: underline">5</span> 6 8</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 __ 30 __ __ 40</span>

<span style="color: Blue">  <span style="text-decoration: line-through">2</span> 3 <strong>4</strong> <span style="text-decoration: underline">5</span> 6 8 9</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 __ __ 40 45</span>

<span style="color: Blue">    <span style="text-decoration: line-through">3</span> <strong>4</strong> 5 <span style="text-decoration: underline">6</span> 8 9 10</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 __ __ 40 45 __ 50</span>

<span style="color: Blue">    <span style="text-decoration: line-through">3</span> 4 <strong>5</strong> 6 <span style="text-decoration: underline">8</span> 9 10 12</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 __ 36 40 45 __ 50 __ 60</span>

<span style="color: Blue">      <span style="text-decoration: line-through">4</span> 5 <strong>6</strong> <span style="text-decoration: underline">8</span> 9 10 12 15</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 __ 36 40 45 __ 50 __ 60 __ __ 75</span>

<span style="color: Blue">      <span style="text-decoration: line-through">4</span> 5 <strong>6</strong> 8 <span style="text-decoration: underline">9</span> 10 12 15 16</span>
<span style="color: FireBrick">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 45 48 50 __ 60 __ __ 75 80</span>
</pre>

<p>Unfortunately, this doesn't really tell you anything about the asymptotic
behavior of each respective implementation.
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Fri, 04/01/2005 - 19:53 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5206"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5206" class="active">Re: Space Complexity</a></h3>
 <div class="content"><blockquote>Since I don't have the required number-theoretical skills
to estimate the sizes of the aforementioned sequence
intervals</blockquote>

<p>(Other than observing trivially that the space complexity is no
worse than <em>O(n)</em> in both cases.)</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Fri, 04/01/2005 - 20:37 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5229"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5229" class="active">Not convinced it is trivial</a></h3>
 <div class="content"><p >Thanks for taking the time to write out the sets! </p>
<p >While observing the "previously computed" numbers does make it appear as if the Haskell version doesn't require storage greater than N, this is not neccessarily the case. There is also a need for temporary storage as well at each iteration, which could possibly increase asymptotically greater than the rate of N. Is it easy to do the analysis of the cost of the lazy evaluation temporary storage?</p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Sat, 04/02/2005 - 18:18 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5240"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5240" class="active">expected Haskell behavior in pseudo-code</a></h3>
 <div class="content"><blockquote>... does make it appear as if the Haskell version doesn't require
storage greater than N, this is not neccessarily the case.</blockquote>


<p>The <em>O(n)</em> estimate is based on the assumption that given a moderately
smart compiler, the Haskell implementation can work internally along the
following lines (excuse my bad Scheme):</p>

<pre>(define (make-hamming)
  (let* ((tail '(1))
         (s2 tail)
         (s3 tail)
         (s5 tail))
    (lambda ()
      (let* ((result (car tail))
             (h2 (* 2 (car s2)))
             (h3 (* 3 (car s3)))
             (h5 (* 5 (car s5)))
             (next (min h2 h3 h5)))
        (set-cdr! tail `(,next))
        (set! tail (cdr tail))
        (if (= h2 next)
            (set! s2 (cdr s2)))
        (if (= h3 next)
            (set! s3 (cdr s3)))
        (if (= h5 next)
            (set! s5 (cdr s5)))
        result))))</pre>

<p>Storage-wise, this behaves like the blue sequence in <a
href="/node/view/608#comment-5204">my previous comment</a>, provided that the
above snippet really works the way I think it does.</p></div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Mon, 04/04/2005 - 00:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5248"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5248" class="active">Re: Space Complexity -- Haskell wins</a></h3>
 <div class="content"><p>To follow up on my <a href="/node/view/608#comment-5206">earlier
comment</a>
</p>

<blockquote>the space complexity is no worse than <code>O(n)</code> in both
 cases.
</blockquote>

<p>In the C++ case, the <em>O(n)</em> estimate cannot be improved, given an
implementation like the one fleshed out in <a
href="/node/view/608#comment-5130">marcin's post</a>.</p>

<p>The Haskell implementation seems to be doing a little better than
<em>O(n)</em> based on the following empirical data:</p>

<table border="1" cellspacing="0" cellpadding="2">
<tr>
  <th>Step #</th>
  <th>Tail size</th>
  <th>tail size / step #</th>
</tr>
<tr align="right">
 <td>10</td>
 <td>7</td>
 <td>0.70</td>
</tr>
<tr align="right">
  <td>100</td>
  <td>44</td>
  <td>0.44</td>
</tr>
<tr align="right">
  <td>1000</td>
  <td>228</td>
  <td>0.23</td>
</tr>
<tr align="right">
  <td>10,000</td>
  <td>1,108</td>
  <td>0.11</td>
</tr>
<tr align="right">
  <td>100,000</td>
  <td>5,253</td>
  <td>0.05</td>
</tr>
<tr align="right">
  <td>1,000,000</td>
  <td>24,623</td>
  <td>0.02</td>
</tr>
</table>

<p>The table basically says that assuming the Haskell implementation behaves as
described in <a href="/node/view/608#comment-5240">this post</a>, it needs to
remember 44 previous numbers in order to compute the 100th.  It needs to
remember 24,623 previous numbers in order to compute the 1,000,000th.  On the
face of it, that seems to be more efficient than <em>O(n)</em>.
</p>


<p>(As a sanity check for my Python script, I should probably ask <a
href="/node/view/608#comment-5241">Anton</a> to verify whether or not the
1,000,000th Hamming number is
519381797917090766274082018159448243742493816603938969600000000000000000000000000000,
assuming you count 1 as the 0th number.)
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Mon, 04/04/2005 - 14:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5250"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5250" class="active">Sanity confirmed (in some narrow sense)</a></h3>
 <div class="content"><blockquote ><p >
(As a sanity check for my Python script, I should probably ask Anton to verify whether or not the 1,000,000th Hamming number is 519381797917090766274082018159448243742493816603938969600000000000000000000000000000, assuming you count 1 as the 0th number.)
</p></blockquote>
<p >Yes, it is.</p>
<pre >
&gt; seq !! 0
1
&gt; seq !! 1000000
519381797917090766274082018159448243742493816603938969600000000000000000000000000000
&gt; elemIndex 519381797917090766274082018159448243742493816603938969600000000000000000000000000000 seq
Just 1000000
</pre><p >That last expression used a cut &amp; paste from the original quoted number, to make sure they matched.</p></div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Mon, 04/04/2005 - 17:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5292"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5292" class="active">Approximation</a></h3>
 <div class="content"> Sloane's <a href ="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A051037">on-line encyclopedia of integer sequences</a> is always a useful reference.
In 
<a href ="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A051037">this case</a> it provides the approximation

<pre>
f n = (ln (n * sqrt 30)) ** 3 / (6 * ln 2 * ln 3 * ln 5) + O(lnln n)
</pre>

for the number of hamming numbers smaller than n. Let's forget about the last term, and invert the formula to obtain the nth hamming number

<pre>
h n = exp ((n * (6 * ln 2 * ln 3 * ln 5))**(1/3)) / sqrt 30
</pre>

Test: <code>h 1000000  = 5.183690169e83</code>: close enough for me. Now the tail size, as you call it, is

<pre>
tailsize n = n - f (h n / 5)
</pre>

Test: </p>

<table border="1" cellpadding="2" cellspacing="0">
<tbody><tr>
  <th>Step #</th>
  <th>Tail size</th>
  <th>Approx</th>
</tr>
<tr align="right">
 <td>10</td>
 <td>7</td>
 <td>7.66</td>
</tr>
<tr align="right">
  <td>100</td>
  <td>44</td>

  <td>44.52</td>
</tr>
<tr align="right">
  <td>1000</td>
  <td>228</td>
  <td>228.31</td>
</tr>
<tr align="right">
  <td>10,000</td>

  <td>1,108</td>
  <td>1,108.77</td>
</tr>
<tr align="right">
  <td>100,000</td>
  <td>5,253</td>
  <td>5,254.48</td>

</tr>
<tr align="right">
  <td>1,000,000</td>
  <td>24,623</td>
  <td>24,624.33</td>
</tr>
</tbody></table>

<p>
The approximation is not far off.
The right-hand side of <code>tailsize</code> can be rewritten as
</p>

<pre>
tailsize
    =   (ln 5 * 3*c**(-1/3)*n**(2/3) - 3*(ln 5)**2 *c**(-2/3)*n**(1/3) + ln 5**3/c)
    where
        c =   6*(ln 2)*(ln 3)*(ln 5)
</pre>

<p>
and this approximately
</p>

<pre>
tailsizeapprox n
    =   2.48*n**(2/3) - 2.05*n**(1/3) + 0.57)
</pre>

<p>
So yes, this is sublinear.
</p>

<p>
Now, all the complexity measures discussed so far seem to assume that integer operations are constant time and  integers are constant size.
If we take into account that the size of the hamming numbers grows than it changes.
The size in bits of the nth hamming number is

<pre>
sizeh n = log (h n) / log 2
</pre>

The log nicely cancels out with the <code>exp</code> in <code>(h n)</code>,

<pre>
sizeh n = (2*(c*n)**(1/3)-ln 2-ln 3-ln 5)/(2 * ln 2)
    where
        c =   6*(ln 2)*(ln 3)*(ln 5)
</pre>

This function has the form

<pre>
sizeh n = c1 + c2 * n**(1/3)
</pre>

We can approximate the size of the first n hamming numbers <code>sum [sizeh n | i <- [0..n]]</code> with the integral

<pre>
sizehrange n = c1 * n + 3/4 * c2 * n**(4/3)
</pre>

The size of the hamming numbers in the tail is

<pre>
tailsize = sizehrange n - sizehrange (f (h n / 5))
</pre>

Now this gets messy, but the function is still dominated by the <code>n**(4/3)</code> factor, which makes it superlinear. For example <code>tailsize 1,000,000</code>
= 6819368.46 bit = 832KB. Does this seem about right?


</div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Tue, 04/05/2005 - 19:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-5297"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5297" class="active">Perl implementation with lazy streams</a></h3>
 <div class="content"><p>Thanks for your analysis. Beautifully done.  Thanks a million.
</p>

<blockquote>For example <code>tailsize 1,000,000</code> = 6819368.46 bit =
832KB. Does this seem about right?</blockquote>

<p>Since I don't have a Haskell compiler installed, I'm going to have to pass
this question on to <em>Anton "the sanity checker" van Straaten</em>.  (My
Python script doesn't currently discard numbers that are no longer needed and
I'm too lazy to fix it.)
</p>

<p>As an aside, the AT&amp;T Encyclopedia of Integer Sequences links to a <a
href="http://perl.plover.com/Stream/stream.html">nice article</a> by Mark
Dominus (the author of <a href="http://perl.plover.com/hop/"><em>Higher-Order
Perl</em></a>) that shows how to solve the Hamming problem in Perl using Mark's
own <a href="http://perl.plover.com/Stream/Stream.pm">lazy streams module</a>.
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 04/05/2005 - 20:15 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5230"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5230" class="active">Aside: time complexity</a></h3>
 <div class="content"><p >This reminds me of something I have wondered: what is the time complexity of <code >append</code> (as in <code >++</code>) in a lazy language? I've heard that it's O(n) just like in a strict language but in my fuzzy mental picture I expect it to be O(1). Know what I mean?</p></div>
 <div class="links">By <a href="user/465" title="View user profile.">Luke Gorrie</a> at Sat, 04/02/2005 - 18:28 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5232"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5232" class="active">What, because strictly speaki</a></h3>
 <div class="content"><p >What, because strictly speaking, a lazy language ought to print out [1,2,3]++[4,5,6] by printing the elements of the first list, then the elements of a second, rather than running over the first list, adding it into a new list, then adding the elements of the second to that list, then run over that new list printing out its elements?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Sat, 04/02/2005 - 18:51 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5234"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5234" class="active">IO lists</a></h3>
 <div class="content">Right.
<p>
In Erlang we have a very useful related datatype called an <i>IO list</i> to represent binary data that will ultimately be written to a file or socket. While we represent plain binary data as either a string (list of 8-bit integers) or a <i>binary</i> (array of 8-bit integers) an IO list is a "deep list" (tree of conses) of these elements. What this means is that if you have two chunks of data to join together you can cons them into an IO list in O(1) time instead of having to concatenate them in O(n) time. In practice this makes it very easy to avoid the pitfall of spending O(n^2) time to accumulate large binary messages from the repeated concatenation of smaller parts.
<p>
Take HTML generation in the <a href="http://yaws.hyber.org/">Yaws</a> webserver for an example:
<pre>
ehtml_expand({Tag, Attrs, Body}) when atom(Tag) ->
    Ts = atom_to_list(Tag),
    NL = ehtml_nl(Tag),
    [NL, "<", Ts, ehtml_attrs(Attrs), ">", ehtml_expand(Body), "&lt;/", Ts, ">"];
</pre>
If the last line was instead <code>NL ++ "<" ++ Ts ++ ...</code> then in a strict language like Erlang we would take O(n^2) time to generate the HTML. How about in e.g. Haskell?
<p>
Creating these IO lists is cheap but of course they will ultimately need to be written to a file descriptor. At this point either the runtime system concatenates the IO list into a byte array in memory (O(n) using relatively fast C code - the <code>list_to_binary</code> primitive) or a <code>writev</code> system call could be used and might avoid ever concatenating the data in memory at all.
<p>
This has a lot in common with Boehm's most excellent <a href="http://www.x86-64.org/cgi-bin/cvsweb.cgi/gcc.dead/boehm-gc/cord/cord.h?rev=1.1.1.1&content-type=text/x-cvsweb-markup">cord</a> data structure.</div>
 <div class="links">By <a href="user/465" title="View user profile.">Luke Gorrie</a> at Sat, 04/02/2005 - 23:07 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5233"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5233" class="active">Not sure,</a></h3>
 <div class="content"><p >but if I remember correctly, there are both amortized and worst-case O(1) lazy append's given in CTM and I think I saw them in Okasaki too (Purely Functional Datastructures).</p></div>
 <div class="links">By <a href="user/372" title="View user profile.">Martijn Vermaat</a> at Sat, 04/02/2005 - 19:08 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5208"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5208" class="active">Functional nearly-one-liner</a></h3>
 <div class="content"><pre style="font-size:100%;font-style:normal;">
ham1:: [Int] 
ham1 = y  
where y = [1:merge (map ((*) 2) y) (merge (map ((*) 3) y) (map ((*) 5) y))]
</pre>


<p>
via <a href="http://www.cs.ru.nl/~clean/CleanExtra/report20/chapter3/s36.html">Clean</a>.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Fri, 04/01/2005 - 23:02 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5211"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5211" class="active">Why can this not be written a</a></h3>
 <div class="content"><p >Why can this not be written as one or two lines? Why are the last two lines separate?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Sat, 04/02/2005 - 00:47 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5220"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5220" class="active">I just paste them...</a></h3>
 <div class="content"><p >...as the author posts them.  Call it a two-liner then.</p></div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sat, 04/02/2005 - 09:07 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5223"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5223" class="active">Top-level sharing</a></h3>
 <div class="content"><p >In Clean by default top level functions are reevaluated.<br >
So if you write this as</p>
<pre >
ham1:: [Int] 
ham1 = [1:merge (map ((*) 2) ham1) (merge (map ((*) 3) ham1) (map ((*) 5) ham1))]
</pre><p >
then <code >ham1</code> is reevaluated over and over again.</p>
<p >There's a special definition symbol (=:) to indicate that the <a href="&lt;br">
"http://foldoc.hld.c64.org/foldoc.cgi?CAF"&gt;CAF</a> should be shared.</p>
<pre >
ham1:: [Int] 
ham1 =: [1:merge (map ((*) 2) ham1) (merge (map ((*) 3) ham1) (map ((*) 5) ham1))]
</pre><br ></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Sat, 04/02/2005 - 12:07 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5212"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5212" class="active">Haskellish nearly-one-liner</a></h3>
 <div class="content"><pre>
hamming :: Num -> [Num]
hamming n = [i | i <- [1..n], i `mod` 2 == 0 || i `mod` 3 == 0 || i `mod` 5 == 0 ]
</pre>

<p>
<a href="http://www.csse.uwa.edu.au/~jeff/CS120/1998/CS120Teaching/11.%20Lists.html">via</a> Professor <a href="http://www.csse.uwa.edu.au/~jeff/">Jeff Rohl</a> using the old Haskell relative, <a href="http://www.computer-dictionary-online.org/Gofer.htm?q=Gofer">Gofer</a>.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sat, 04/02/2005 - 01:06 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5213"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5213" class="active">Correctness...</a></h3>
 <div class="content"><p>
Pasted verbatim, not checked.  Possible errors: logical operator, assumption that all numbers divisible by 2,3, and 5 are strictly Hamming numbers.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sat, 04/02/2005 - 01:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5219"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5219" class="active">Functional one-liner in Mathematica</a></h3>
 <div class="content"><p>
(Edit.  See my <a href="http://lambda-the-ultimate.org/node/view/608#comment-5746">later comments</a> for code corrections and remarks.  There's nothing wrong with the idea here - though the code is incorrect, it's easily fixed.)
</p>

<pre style="font-size:120%;font-style:normal;">
Sort[Flatten[Table[2^i*3^j*5^k,{i,0,5},{j,0,5},{k,0,5}]]]
</pre>

<p>
This one-liner is trivial, lucid, and fast.  I'm a C++ guy too, but not provincial.  C++ is wrong for Hamming numbers.
</p>

<p>
Using the same command format on a 1.0 GHz PC, Mathematica 5.1.1 computed and sorted the first 27000 Hamming numbers in 0.3 second.  The 27000th number is 6863037736488300000000000000000000000000000.
</p>

<p>
In all cases memory allocation is optimal because the array is allocated once according to the Table size.  The C++ code is another question.
</p>

<p>
The C++ code fails outright at the 10791st Hamming number.  This is the first Hamming number greater than 2^64.  If the hardware is only 32-bit, C++ fails at the 1846th Hamming number.  Big-ints are the worry, not efficiency.  Mathematica handles them seamlessly, as do certain other languages.  C++ does not.  This example makes being "close to the hardware" a curse.
</p>

<p>
And I seriously doubt that C++ is faster with "small" Hamming numbers.  Mathematica's computation of the first 216 Hamming numbers was essentially instantaneous.  They are shown below as output from the one-liner.
</p>


<p style="color:red;">
{1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 135, 144, 150, 160, 162, 180, 200, 216, 225, 240, 243, 250, 270, 288, 300, 324, 360, 375, 400, 405, 432, 450, 480, 486, 500, 540, 600, 625, 648, 675, 720, 750, 800, 810, 864, 900, 972, 1000, 1080, 1125, 1200, 1215, 1250, 1296, 1350, 1440, 1500, 1620, 1800, 1875, 1944, 2000, 2025, 2160, 2250, 2400, 2430, 2500, 2592, 2700, 3000, 3125, 3240, 3375, 3600, 3750, 3888, 4000, 4050, 4320, 4500, 4860, 5000, 5400, 5625, 6000, 6075, 6250, 6480, 6750, 7200, 7500, 7776, 8100, 9000, 9375, 9720, 10000, 10125, 10800, 11250, 12000, 12150, 12500, 12960, 13500, 15000, 16200, 16875, 18000, 18750, 19440, 20000, 20250, 21600, 22500, 24300, 25000, 27000, 28125, 30000, 30375, 32400, 33750, 36000, 37500, 38880, 40500, 45000, 48600, 50000, 50625, 54000, 56250, 60000, 60750, 64800, 67500, 75000, 81000, 84375, 90000, 97200, 100000, 101250, 108000, 112500, 121500, 135000, 150000, 151875, 162000, 168750, 180000, 194400, 202500, 225000, 243000, 253125, 270000, 300000, 303750, 324000, 337500, 405000, 450000, 486000, 506250, 540000, 607500, 675000, 759375, 810000, 900000, 972000, 1012500, 1215000, 1350000, 1518750, 1620000, 2025000, 2430000, 2700000, 3037500, 4050000, 4860000, 6075000, 8100000, 12150000, 24300000}
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sat, 04/02/2005 - 09:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5224"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5224" class="active">Mathematica not comparable to Haskell</a></h3>
 <div class="content"><blockquote>Using the same command format on a 1.0 GHz PC, Mathematica 5.1.1 computed and sorted the first 27000 Hamming numbers in 0.3 second. The 27000th number is 6863037736488300000000000000000000000000000.</blockquote>
<p>Compare this to ghc on a 1.3 GHz box. Using the concise source code the program calculates the 27000th number <em>correctly</em> as 3983823817623774429511680, in 0.12 second.</p>
<p>The Mathematica code is very nice as long as you realize it demands care, because it generates many but not all of the Hamming numbers.</p></div>
 <div class="links">By <a href="user/336" title="View user profile.">Scott Turner</a> at Sat, 04/02/2005 - 12:35 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5226"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5226" class="active">some missing</a></h3>
 <div class="content"><p >Your output implies that all Hamming numbers between 7776 and 24300000 are multiples of 5.</p>
<p >coincidently, 7776 = 2^5 * 3^5.</p></div>
 <div class="links">By <a href="user/1154" title="View user profile.">Robbie Mouat</a> at Sat, 04/02/2005 - 15:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5227"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5227" class="active">Haskell sez: bring it!</a></h3>
 <div class="content"><p >I'm not even a Haskell programmer, but Haskell's spirit is channelling through me and forcing me to point out that it can do this very concisely too:</p>
<pre >
hamming = sort [2^i*3^j*5^k | i <p >
Of course, it suffers from the same drawbacks pointed out by Scott.</p></div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Sat, 04/02/2005 - 16:21 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5943"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5943" class="active">Templates to the rescue!</a></h3>
 <div class="content"><p><i>The C++ code fails outright at the 10791st Hamming number. This is the first Hamming number greater than 2^64. If the hardware is only 32-bit, C++ fails at the 1846th Hamming number. Big-ints are the worry, not efficiency. Mathematica handles them seamlessly, as do certain other languages. C++ does not. This example makes being "close to the hardware" a curse.</i></p>

<p>If you look at the sample C++ (iterators) versions above, you can see that by replacing the type held in the list<> or set<> you can get different storages. If you used something like GMP's big int's library, I'd imagine everything would carry on as if nothing had changed. That's where "close to the hardware" gives you choice.</p></div>
 <div class="links">By <a href="user/1873" title="View user profile.">genneth</a> at Thu, 04/28/2005 - 15:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5944"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5944" class="active">Templates to the Rescue, Indeed</a></h3>
 <div class="content">genneth: <i>If you look at the sample C++ (iterators) versions above, you can see that by replacing the type held in the list<> or set<> you can get different storages. If you used something like GMP's big int's library, I'd imagine everything would carry on as if nothing had changed. That's where "close to the hardware" gives you choice.</i>
<p><p>
On the contrary, that's where parametric polymorphism gives you choice, and C++ is a relative latecomer to the parametric polymorpism game. OK, not as late as Java... :-)

In fact, C++'s parametric polymorphism still isn't as expressive as, e.g. O'Caml's. This isn't legal C++:
<p>
<code>
template &lt;typename T&gt;<br>
typedef foo &lt;T&gt; bar &lt;T&gt;;<br>
</code>
<p>
whereas this is legal O'Caml:
<p>
<code>
type 'a bar = 'a foo
</code>
</div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Thu, 04/28/2005 - 16:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5945"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5945" class="active">C++ and parametric polymorphism</a></h3>
 <div class="content"><blockquote>
C++'s parametric polymorphism still isn't as expressive as, e.g. O'Caml's. This isn't legal C++:
<pre>
template &lt;typename T&gt;
typedef foo &lt;T&gt; bar &lt;T&gt;;
</pre>
whereas this is legal O'Caml:
<pre>
type 'a bar = 'a foo 
</pre>
</blockquote>

That's true, but not the greatest example, since in C++ you can do
<pre>
template&lt;typename T&gt;
struct bar {
  typedef foo&lt;T&gt; type;
};
</pre>

and <pre>typename bar&lt;T&gt;::type</pre> is now a type alias.

<p>My first complaint about C++ parametric functions would be that C++ parametric functions can't be passed as arguments.</div>
 <div class="links">By <a href="user/118" title="View user profile.">Jim Apple</a> at Thu, 04/28/2005 - 17:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-21010"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-21010" class="active">My first complaint about</a></h3>
 <div class="content"><blockquote ><p >
My first complaint about C++ parametric functions would be that C++ parametric functions can't be passed as arguments.
</p></blockquote>
<p >the lack of first class parametric functions is indeed one of the more serious issues with c++. a solution to the problem is possible through wrapping the parametric function inside a non-parametric object. ugly, but it works:</p>
<pre >
struct foo {
    template&lt;typename T&gt;
    static void bar(T t) { }
};

template&lt;typename T&gt;
void test(T f) { T::bar("test"); }

int main() {
    test( foo() );
}
</pre><p >
while many defiancies in c++ (like the aforementioned generic typedefs) will be addressed in near future, this and similar issues are unfortunately bound to stay because of the kludgy parametricity design.</p></div>
 <div class="links">By <a href="user/2535" title="View user profile.">peter steiner</a> at Sat, 09/09/2006 - 22:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9644"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9644" class="active">Isn&#039;t 64 a hamming number?</a></h3>
 <div class="content"><p >The sequence above does not contain it.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Sat, 09/17/2005 - 11:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5222"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5222" class="active">...that works wonders</a></h3>
 <div class="content"><p>
(Edit.  See my <a href="http://lambda-the-ultimate.org/node/view/608#comment-5746">later comments</a> for code corrections and remarks.  About this notion of finding stand-alone Hamming numbers, the corrected array code uses an isosurface boundary which I expect might help.  There may be valid formulas from other inspirations, too.)
</p>

<p>
One need not compute any previous Hamming numbers to explore all of them:
</p>

<pre style="font-size:120%;font-style:normal;">
Sort[Flatten[Table[2^i*3^j*5^k,{i,100,105},{j,100,105},{k,100,105}]]]
</pre>

<p>
works just as fast.  The front and back of the resulting output is:
</p>

<pre style="font-size:120%;color:red;">
{5153775207320113310364611297656212727021075220010\
00000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000,
10307550414640226620729222595312425454042150440020\
00000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000,
15461325621960339931093833892968638181063225660030\
00000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000,
...etc...
12523673753787875344186005453304596926661212784624\
30000000000000000000000000000000000000000000000000\
00000000000000000000000000000000000000000000000000\
000000}
</pre>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sat, 04/02/2005 - 09:41 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5225"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5225" class="active">Hamming subsequence with no gaps</a></h3>
 <div class="content"><blockquote>One need not compute any previous Hamming numbers to
explore all of them</blockquote>


<p>If you want to compute a <em>contiguous</em> Hamming subsequence in the
interval of [<em>M</em>, <em>N</em>], then you need to find all triples
(<em>i</em>, <em>j</em>, <em>k</em>) such that</p>

<div style="text-align: center; font-style: italic">
log(M) &lt; i*log(2) + j*log(3) + k*log(5) &lt; log(N)
</div>

<p>If you know a way to do this without computing all previous Hamming numbers
less than <em>M</em>, please share. </p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Sat, 04/02/2005 - 14:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5228"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5228" class="active">Some more comments</a></h3>
 <div class="content"><p >This is wonderfully exciting stuff! I am having a lot of fun, I hope we keep this thread alive for a while, because I am writing the Unimperative version.<br >
<p >
For those who don't remember Unimperative is a functional programming C++ subset I posted about a while back, which has been reposted (at  <a href="http://www.ootl.org">http://www.ootl.org</a> ) after having been taken offline for an overhaul (it now works on GCC 3.4 and no longer needs the Boost library).<br >
<p >
The following is not tested (I need a couple of more days) but I wanted to post it for fun, to see if it is comprehensible without documentation, (a tall order I realize, but I am just shooting darts here):</p>
<pre >
Def Merge =
  (Switch,
    (IsEmpty, _1), _2,
    (IsEmpty, _2), _1,
    Default,
    (If,
      (Lt, (Head, _1), (Head, _2)),
      (MakeList, (Head, _1), (Merge, (Tail, _1), _2))
      (MakeList, (Head, _2), (Merge, _1, (Tail, _2)))
    )
  );

Def Merge3 =
  (Merge,
    (Merge, _1, _2),
    _3
  );

Def Hamming2 = (Map, _1, (Lambda, Mult, 2));
Def Hamming3 = (Map, _1, (Lambda, Mult, 3));
Def Hamming5 = (Map, _1, (Lambda, Mult, 5));

Def Hamming =
  (If, GtZ, _1
    (Merge3,
      (Hamming2, (Hamming, (Dec, _1))),
      (Hamming3, (Hamming, (Dec, _1))),
      (Hamming5, (Hamming, (Dec, _1)))
    ),
    (MakeList, 1)
  );
</pre><p >
It the syntax recognizable to functional programmers? I am not very experienced in functional languages. A little hint _1 refers to the first argument, and a function is evaluated when it follows a left paranthesis, and If is lazily evaluated.</p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Sat, 04/02/2005 - 17:47 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5231"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5231" class="active">This looks horrible. At first</a></h3>
 <div class="content"><p >This looks horrible. At first I thought it looked like prolog.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Sat, 04/02/2005 - 18:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5249"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5249" class="active">I guess you don&#039;t like Scheme</a></h3>
 <div class="content"><p >Unimperative syntax was inspired by Scheme. IMO they are quite closely related. </p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Mon, 04/04/2005 - 15:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5251"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5251" class="active">Inspired by scheme in what wa</a></h3>
 <div class="content"><p >Inspired by scheme in what way? As a language whose syntax and style should be avoided at all costs?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Mon, 04/04/2005 - 17:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5252"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5252" class="active">Syntax, dialogue</a></h3>
 <div class="content"><p ><em >Inspired by scheme in what way? As a language whose syntax and style should be avoided at all costs?</em></p>
<p >Wow, great burn!</p></div>
 <div class="links">By <a href="user/118" title="View user profile.">Jim Apple</a> at Mon, 04/04/2005 - 18:51 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5253"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5253" class="active">What Style Would That Be?</a></h3>
 <div class="content"><p >marcin: <i >Inspired by scheme in what way? As a language whose syntax and style should be avoided at all costs?</i></p>
<p >The style of the Lambda Calculus? The functional style, which at least in the form of SSA even seems to underlie modern imperative/OO language implementations? That style?</p>
<p >Or perhaps you mean the syntax that even John McCarthy didn't want, but later conceded was likely crucial to Lisp's survival? That syntax?</p>
<p >Really, there's very little in the realm of programming language discussion more tiresome than the endless rants about Lisp's "shortcomings." Although the recent ll-discuss post about overcoming C++ "brainwashing" in favor of Lisp surely is up there, too.</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Mon, 04/04/2005 - 19:23 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-5254"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5254" class="active">You&#039;re really saying that tha</a></h3>
 <div class="content"><p >You're really saying that that code looks like an s-expr based language, Scheme, or otherwise?</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Mon, 04/04/2005 - 19:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-5261"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5261" class="active">Close Enough for Government Work</a></h3>
 <div class="content"><p >marcin: <i >You're really saying that that code looks like an s-expr based language, Scheme, or otherwise?</i></p>
<p >I see a lot of functions in prefixes, and some occasional "syntax" (if, etc.) It looks slightly more verbose than plain s-exprs, but not to the extent of, say, XML.</p>
<p >But that wasn't what I was responding to: I was responding to what I perceived as a typical rant against s-exprs. If I misunderstood, I apologize.  I think I let my feelings about the ll-discuss post color my perceptions, albeit, ironically, from the opposite perspective!</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Tue, 04/05/2005 - 01:01 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-5266"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5266" class="active">Unimperative s-exprs</a></h3>
 <div class="content"><p >The right hand sides of the definitions do look exactly like s-exprs, except that they have commas between their terms.  Just dropping the commas and adding meaningful lexical names, which would require Lambda to take a formals list, would make it look a lot like Scheme.</p></div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Tue, 04/05/2005 - 05:50 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-5268"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5268" class="active">Yes - that&#039;s my point: If you</a></h3>
 <div class="content"><p >Yes - that's my point: If you change all of the syntax by dealing with left-hand sides, adding formal lists, removing commas, and not having hanging brackets (a particular bugbear of mine), then you would have something that looks like scheme. In the same way, if you put brackets around every function application in C++, and put operators into prefix positions, you would have something looks like scheme, and absolutely nothing like it looks now.</p></div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 04/05/2005 - 07:29 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:200px;">
<a id="comment-5278"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5278" class="active">
If you change all of the sy</a></h3>
 <div class="content"><blockquote>
If you change all of the syntax by dealing with left-hand sides, adding formal lists, removing commas, and not having hanging brackets (a particular bugbear of mine), then you would have something that looks like scheme
</blockquote>

These are all very minor syntactic details as far as a language comparison goes. However, I don't know what is a "hanging bracket". 

<blockquote>
 In the same way, if you put brackets around every function application in C++, and put operators into prefix positions, you would have something looks like scheme</blockquote>
<p>
Unimperative is actually C++! Go check out the following links:
<a href="http://www.ootl.org/uni/uni_tests.hpp.htm">http://www.ootl.org/uni/uni_tests.hpp.htm</a> and <a href="http://www.ootl.org/uni/standard.uni.htm">http://www.ootl.org/uni/standard.uni.htm</a>. The Unimperative implementation as C++ is freely available online at: <a href="http://www.ootl.org/uni/uni.hpp.htm">http://www.ootl.org/uni/uni.hpp.htm</a>
<p>
I really don't believe it is possible to make C++ much more Scheme like than what Unimperative does. 

   </div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Tue, 04/05/2005 - 14:51 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:225px;">
<a id="comment-5282"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5282" class="active">Can you explain why the diffe</a></h3>
 <div class="content">Can you explain why the differences are "minor"? How are you quantifying language differences?<p>
Finally, whether or not it is possible to make a C++ compiler accept a programme that looks as much like Scheme as you believe unimperative does is not the issue - the issue is that one can specify a translation from C++ to scheme syntax that requires fewer rules than the translation between Unimperative syntax and scheme syntax. The fact is that there is not a trivial mapping to lisp-like syntax from the Unimperative, unlike for example, from XML to S-exprs.</div>
 <div class="links">By <a href="user/1754" title="View user profile.">Marcin Tustin</a> at Tue, 04/05/2005 - 17:44 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:250px;">
<a id="comment-5284"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5284" class="active">I can&#039;t believe you that it i</a></h3>
 <div class="content"><p >I can't believe you that it is a <b >fact</b> that there is no trivial mapping from Unimperative to Lisp syntax. I will demonstrate shortly on LtU, that there is in fact a trivial mapping. </p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Tue, 04/05/2005 - 18:04 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5237"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5237" class="active">Death by a thousand cuts</a></h3>
 <div class="content"><p>
(Edit.  Final and correct array code is shown in my <a href="http://lambda-the-ultimate.org/node/view/608#comment-5746">last reply</a>, below.  The points here remain valid.)
</p>

<p>
This is not a language shootout or speed contest, but an idiom contest.  Haskell is a fine language.  So is C++.  Mathematica is very nice.  All can be fast, and a faster CPU like Scott's will run them faster.  We are discussing idioms.  My only reason to offer stats was to corral the usual C++ hobby horses of speed and hardware proximity.  C++ has no advantages here, which makes the test case a remarkable selection.  The big-int problem even gives hardware proximity a disadvantage.
</p>

<p>
So why did CUJ pick Hamming numbers to compare programming idioms?  I am suspicious.  If Hamming(N) necessitates imperative stepwise algorithms, then the challenge is rigged.  An objective challenge requires an objective test.  (Disclosure, I haven't read the CUJ article for lack of access.)
</p>

<p>
What amuses me is that Hamming(N) is a number-theoretic sort of problem.  Few workers in that field think that C++ surpasses tools like Mathematica (Haskell, Lisp, whatever) for such work.
</p>

<p>
The kind corrections are partly right and partly wrong.  Here is the issue.  Table generates all forms 2^i*3^j*5^k.  It is wrong to say that Table misses some numbers.  Set the bounds high enough and it produces all numbers of this type, i.e. "all Hamming numbers."  It produces them exhaustively and without duplicates, an important advantage.  It permits one to study high Ns without computing previous values, even if without a proper Hamming index.  The code is therefore "complete" in a certain sense, if not the right sense according to Hamming.
</p>

<p>
The bug is a boundary effect.  It may be O(N^3), I don't know, but if C++ overflows at 2^64, one must ask which scenario is worse.
</p>

<p>
The one-liner's avoidance of duplicates might pay for a simple way to fix the boundary using another type of waste.  Generate a bigger Table and truncate the bad data.  Some clever formula might exist, but a simple test on Hamming(27000) shows that it's indeed a boundary glitch:
</p>


<pre style="font-size:120%;color:black;">
In[181]:=
(* one-liner formatted only for LtU wraparound *)
hammingNums = With[{n= 82},
    Take[Sort[Flatten[
        Table[2^i*3^j*5^k,{i,0,n-1},{j,0,n-1},{k,0,n-1}]
    ]],Floor[ (n^3) / 2  ]]];

In[182]:=
Length[hammingNums]
</pre>

<pre style="font-size:120%;color:red;">
Out[182]=
275684
</pre>

<pre style="font-size:120%;color:black;">
In[183]:=
(* check equality with Scott's num *)
hammingNums[[27000]] == 3983823817623774429511680
</pre>

<pre style="font-size:120%;color:red;">
Out[183]=
True
</pre>

<p>
There you go.  Now Hamming(27000) is 2^81.72042812373361, much larger than 2^64.  So, mea culpa:  my quickie one-liner has a boundary glitch, while their C++ segfaults on large N.
</p>

<p>
Incorrect or incomplete assumptions will break any combination of language and idiom.  At least I did not waste time writing bad code in C++.  That's the neat thing about one-liners, they are throw-away.  This one-liner, with whatever fixes it needs (gasp a second line), is certainly not the best or most elegant solution.  The assertion is only that a pithy and obvious functional idiom solution exists, one which is reasonable for this problem, and arguably more so than C++ code which breaks at 2^64 or 2^32.
</p>

<p>
While I could have ported a previous solution into Mathematica as Anton ported mine, porting is not the issue.  I wanted to show an entirely new idiom since that was the original exercise.  In an almost brain-dead condition the functional idiom still produces something workable and simple.
</p>

<p>
We can quibble over "workable" but at least it's a fair starting point.  Analysis of this one-liner will not be very productive.  I would only be curious to see a good boundary formula.  However what would help everyone is a list of the first 100,000 Hamming numbers.  That data would help those writing novel solutions.  It's not my job, though, since I've done my duty here and am going on vacation from Hamming numbers.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sun, 04/03/2005 - 10:31 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5241"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5241" class="active">Helping everyone</a></h3>
 <div class="content"><blockquote>
However what would help everyone is a list of the first 100,000 Hamming numbers. That data would help those writing novel solutions.
</blockquote>
<p>
That's easy: just take the original Haskell solution or one of its shorter derivatives and type "take 100000 seq" at the Haskell prompt.  It's not even a particularly resource-heavy operation.  However, the results probably shouldn't be posted in this thread... :)
</p>
It's also easy to do comparisons with other solutions, e.g. given the original definition of 'seq' as a correct and contiguous sequence of Hamming numbers, we can do this:

<pre>
> let hamming n = sort [2^i*3^j*5^k | i <- [0..n], j <- [0..n], k <- [0..n]]
> let test m n = take m (hamming n) == take m seq
> test 581 20
True
> test 582 20
False
</pre>
<p>
Hey, lucky guess! So the first 581 out of the 21^3=9,261 Hamming numbers generated by <code>(hamming 20)</code> are a contiguous Hamming sequence.  (I'm guessing that's not going to be the most efficient way of finding such sequences.)
<p>
Re the rules of this contest, I was under the impression it most resembled a game of Calvinball. Ha! We're in the "infinity is cheating" zone!
</div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Mon, 04/04/2005 - 01:20 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5247"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5247" class="active">Re: Death by a thousand cuts (!/0)</a></h3>
 <div class="content"><p>Based on the title of your post, I was expecting it to be about Prolog.  No
such luck.</p>

<blockquote>
<p>Table generates all forms <code>2^i*3^j*5^k</code>. It is wrong to say that
Table misses some numbers. Set the bounds high enough and it produces all
numbers of this type.</p>

<p>...</p>

<p>Analysis of this one-liner will not be very productive. I would only be
curious to see a good boundary formula.
</p>
</blockquote>

<p>Say,</p>


<div style="text-align: center; font-style: italic;">
H = { 2<sup>i</sup> * 3<sup>j</sup> * 5<sup>k</sup> &nbsp;|&nbsp; i &lt; N &nbsp;&amp;&nbsp; j &lt; N &nbsp;&amp;&nbsp; k &lt; N }
</div>

<p>Now for the boundary formula.  The following subset of <em>H</em> can be
trivially seen to contain gaps in the Hamming sequence </p>


<div style="text-align: center; font-style: italic;">
W = { h in H &nbsp;|&nbsp; h >= 2<sup>N</sup> }
</div>

<p>To ground this in concrete numbers, take <em>N = 10</em>. Then
</p>


<div style="text-align: center; font-style: italic;">
max(H) = 2<sup>9</sup> * 3<sup>9</sup> * 5<sup>9</sup> = 19,683,000,000,000
</div>

<p><em>W</em> is the wasted subset that consists of all elements of <em>H</em>
that are greater than <em>2<sup>10</sup> = 1024</em>.  The cardinality of
<em>H</em> is 1000.  The cardinality of <em>W</em> is 913.
</p>

<p>I'm too lazy to do real math, but my gut feeling is that you're right.  The
efficiency of the above one-liner is most likely <em>O(n<sup>3</sup>)</em>.
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Mon, 04/04/2005 - 13:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5746"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5746" class="active">I do everything around here</a></h3>
 <div class="content"><p>
<strong>El-vadimo</strong> - The array idiom can be O(N) if done right.  Just follow through as proposed.  The concept has no intrinsic flaw.  Declarative arrays need only correct boundaries - here, tetrahedral, a corner cut from a cube.
</p>

<p>
The proof code below is identical but with a boundary fix.  It checks accurately against Haskell to the limits of available memory.  Mathematica 5.1.1 runs it without external dependencies.
</p>

<pre style="font-size:120%;color:green">
(* Define a "two-liner" function *)
HammingList[N_] := Module[ { A, B, C },
  { A, B, C } = (N^(1/3)) * 
     { 2.8054745679851933, 1.7700573778298891, 1.2082521307023026 } 
     - { 1, 1, 1 };
  Take[Sort[Flatten[Table[ 2^x*3^y*5^z,
     { x, 0, A }, { y, 0, (-B/A)*x + B },
     { z, 0, C-(C/A)*x-(C/B)*y } ]]], N]];

(* Run once to bypass first-run issues  *)
First[Timing[thousand = HammingList[1000];]]
</pre>

<pre style="font-size:120%;color:red">
0. Second
</pre>


<pre style="font-size:120%;color:green">
(* Check performance *)
runtimes = Table[{N, (1/Second)*First[Timing[
    chk =.; chk = HammingList[N];]]},
    {N, 0, 1000000, 50000}];

(* Show formatted results *)
PaddedForm[TableForm[runtimes, TableAlignments ->
    {Right}], {7, 3}, NumberPadding -> {"", " "}]
</pre>

<pre style="font-size:120%;color:red">
      0    0.
  50000    1.
 100000    2.156
 150000    3.375
 200000    4.656
 250000    5.969
 300000    7.328
 350000    8.625
 400000   10.125
 450000   11.422
 500000   12.906
 550000   14.344
 600000   15.719
 650000   17.156
 700000   18.578
 750000   19.859
 800000   21.313
 850000   22.828
 900000   24.406
 950000   25.688
1000000   27.187
</pre>

<p>
These numbers plot a nice straight line showing O(N).  Accuracy validates against Haskell output to well over one million numbers.
</p>


<pre style="font-size:120%;color:green">
(* Check 27000th number   *)
chk[[27000]]
</pre>

<pre style="font-size:120%;color:red">
3983823817623774429511680
</pre>

<pre style="font-size:120%;color:green">
(* Check millionth number *)
chk[[1000000]]
</pre>

<pre style="font-size:120%;color:red">
519312780448388736089589843750000000000000
000000000000000000000000000000000000000000
</pre>

<p>
The "millionth" sanity number from <a href="http://lambda-the-ultimate.org/node/view/608#comment-5248">earlier</a> is the million-and-first.  Yes, this code computes it.  Mathematica arrays index from 1.  If you want the millionth number, you ask for it; if you want the million-and-first, you ask for that.
</p>

<pre style="font-size:120%;color:green">
ck = HammingList[1000000+1];
Last[ck] ==
5193817979170907662740820181594482437424938166039389696
00000000000000000000000000000
</pre>

<pre style="font-size:120%;color:red">
True
</pre>


<p>
All that is why I called premature analysis unhelpful and tried shifting interest to the boundary question.  Analysis will always condemn the wrong shape - cubes, spheres, prisms, or buckyballs.  None of that condemns the array idiom.  The worthwhile effort was to find the right shape.
</p>

<p>
Armchair analysis shows why O(N) stands to reason.  Generating N numbers is O(N).  In this code a proportion are O(N^(2/3)) waste, which vanishes because O(N + N^(2/3)) = O(N).  The waste is typically a few percent of N (small-N cases aside).  This waste compares favorably against duplication waste in Haskell and C++.  Formulas called Ehrhart polynomials could eradicate it altogether.  Flatten is essentially free.  Sorting is O(N log N) in general, but can be O(N) here, since we know a maximum value from the isosurface.
</p>

<p>
Timing values will vary between machines.  The timing experiment is the best simple one I can run.  Smaller N happens so fast as to be unreliable, since OS background tasks jump in and out.  One could average across many runs, I suppose.  Larger N invokes virtual memory, which also breaks validity.  Multiple millions of big-ints quickly tax computer resources.
</p>

<p>
This throw-away code remains terse and easy to understand.  It has room for improvement, like any code.  People can nitpick it or perfect it.  Habitual nitpickers should try the latter option for novelty's sake.
</p>

<hr style="width: 100%; height: 2px;">

<p>
<strong>Anton</strong> - We're on the same side, man.  Quell urges to shoot down allies over small stuff.  We both support functional programming.
</p>

<p>
My lucky guess was deliberately chosen to demonstrate a boundary problem.  Naturally the value barely worked.  That was the point.  On one scale things worked, on another they didn't.
</p>

<p>
I had hoped someone would take the hint.  Boundaries had already been suggested, and that simple go/no-go check validated the intuition.  It did not yield formulas, but confirmed merit in a search.  Somewhere you lost the plot and began Slashdotting.
</p>

<p>
After you leave college, coworkers will express concepts and intuition without proofs on a platter.  Every good idea starts somewhere.  Try to be more encouraging and not kill the baby.
</p>

<p>
This idiom is just one among many which I've posted.  Thank me later for that Haskell find; I like it too.
</p>

<p>
Infinity police should arrest someone else.  Infinitely recursive Haskell streams need it, not arrays.  Everyone praises the infinite-stream (Haskell) solutions.  C. Hendrie's code is very good, I agree.  Let's just be clear about infinities.
</p>

<p>
A reference list quite obviously doesn't belong inline.  The use of Haskell is obvious too.  That sparkling brilliance for the obvious is blinding.  My suggestion was a means for C++ folks to avoid Haskell.  GHC is a 50 MB download/install/learn procedure with a console window, monad I/O, and non-terminating code in this case (CTRL-C and cross your fingers).  LtU's site manager, already running the code and skilled in Haskell, could have done the deed in less time than it took to dismiss.
</p>

<p>
A better offering than a huge list would be a Haskell-compiled executable (not script) that takes N and a file name as arguments, then spills the numbers to disk.  Someone else can work on that, maybe Anton, maybe not.
</p>

<hr style="width: 100%; height: 2px;">

<p>
<strong>Everyone</strong> - The take-home lesson is that functional idioms can solve this problem in several ways.  Some may feel more comfortable than others, but take your pick.
</p>

<p>
Ehud will get a <a href="http://www.wolfram.com/products/mathreader/">MathReader</a> file with graphics and derivation.  LtU still has no way to upload images.
</p>

<p>
I'm not planning to revisit this page.  Questions will have to be answered by the file.  The numerical coefficients incorporate some consolidated arithmetic, so don't twist your brain on them.  Send email through the web interface if there is something that you desperately want me to know.
</p>
</div>
 <div class="links">By <a href="user/787" title="View user profile.">Mark Evans</a> at Sun, 04/24/2005 - 09:58 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5915"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5915" class="active">The promised file</a></h3>
 <div class="content"><p >Here's Mark's <a href="http://lambda-the-ultimate.org/files/HammingNumbersDeclarative.7z">file</a>.</p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Wed, 04/27/2005 - 18:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5933"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5933" class="active">7-zip compressed?</a></h3>
 <div class="content"><br >
<pre >
% file HammingNumbersDeclarative.7z
HammingNumbersDeclarative.7z: 7z archive data, version 0.2
</pre><p >
and there's only an implementation of <a href="http://www.7-zip.org/">7-zip</a> for Windows.<br >
Too bad. </p></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Thu, 04/28/2005 - 08:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-5936"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5936" class="active">Try this.</a></h3>
 <div class="content"><p ><a href="http://p7zip.sourceforge.net/">Try this.</a></p></div>
 <div class="links">By <a href="user/175" title="View user profile.">sjoerd_visscher</a> at Thu, 04/28/2005 - 09:17 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5259"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5259" class="active">Ocaml Solution (purely applicative, O(N log N))</a></h3>
 <div class="content"><P>Here's the Ocaml version of the C++ code (or rather a version):
<PRE>
module Int = struct
    type t = int
    let compare (x: int) y =
        if x &lt; y then
            -1
        else if x == y then
            0
        else
            1
end

module IntSet = Set.Make(Int)

let hamming n = (* generate the first n hamming numbers *)
    let rec loop i accu set =
        if i &lt; n then
            let v = IntSet.min_elt set in
            let set = IntSet.remove v set in
            let set = IntSet.add (v * 2) set in
            let set = IntSet.add (v * 3) set in
            let set = IntSet.add (v * 5) set in
            loop (i+1) (v :: accu) set
        else
            List.rev accu
    in
    loop 0 [] (IntSet.add 1 IntSet.empty)
;;
</PRE></P>

<P>A variation of the Haskell solution is possible, but you'd have to write your own lazy list module (Ocaml doesn't have on in it's standard library).</P>

<P>Hacking the above code to return both the required values and the calculated but not needed values I get:
<TABLE BORDER=1><THEAD><TD>Num Required</TD><TD>Num Remaining</TD></THEAD><TBODY>
<TR><TD>10</TD><TD>13</TD></TR>
<TR><TD>20</TD><TD>21</TD></TR>
<TR><TD>30</TD><TD>26</TD></TR>
<TR><TD>40</TD><TD>32</TD></TR>
<TR><TD>50</TD><TD>36</TD></TR>
<TR><TD>60</TD><TD>41</TD></TR>
<TR><TD>70</TD><TD>46</TD></TR>
<TR><TD>80</TD><TD>49</TD></TR>
<TR><TD>90</TD><TD>54</TD></TR>
<TR><TD>100</TD><TD>57</TD></TR>
<TR><TD>200</TD><TD>88</TD></TR>
<TR><TD>300</TD><TD>117</TD></TR>
<TR><TD>400</TD><TD>140</TD></TR>
<TR><TD>500</TD><TD>161</TD></TR>
<TR><TD>600</TD><TD>183</TD></TR>
<TR><TD>700</TD><TD>202</TD></TR>
<TR><TD>800</TD><TD>221</TD></TR>
<TR><TD>900</TD><TD>238</TD></TR>
<TR><TD>1000</TD><TD>256</TD></TR>
</TBODY></TABLE>
</P>

<P>Unfortunately, at this point I overflow integers.  Trying to calculate the 1238th Hamming Number, I overflow (on 32 bits).  And I don't care enough to recode with larger numbers.</P>

</div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Mon, 04/04/2005 - 22:48 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5265"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5265" class="active">Recoding the hardware</a></h3>
 <div class="content"><blockquote>
Trying to calculate the 1238th Hamming Number, I overflow (on 32 bits). And I don't care enough to recode with larger numbers.
</blockquote>
<p>
On 64 bits (Debian amd64), this same OCaml code overflows when calculating the 10,856th Hamming number.  
</p><p>
BTW, my previous Haskell calc of the first million numbers was done on a sedate old 32-bit 450MHz PIII.  (Insert entirely unreasonable apples-to-kumquats comparative observation here.)
</p>
</div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Tue, 04/05/2005 - 05:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5273"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5273" class="active">Yeah</a></h3>
 <div class="content"><p >Yeah- I fiddle with my code a little bit to see if I could compute hamming numbers large enough that it took signifigant amounts of time on my 1.8GHz Athlon-64.  No dice (yet).</p>
<p >Here's the thing: from my explorations it looks like to find the nth hamming number, you have to compute about n extra numbers- so the total number of hamming numbers you have to compute is O(N).  Each number costs approximately O(log N) to compute (or so- I have some thoughts about that I'll post seperately).  Log of 10,000 is approx. 12, so we're looking at maybe 250,000 operations.  Even on an old, slow P3, this isn't that much calculation.</p></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Tue, 04/05/2005 - 13:11 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5260"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5260" class="active">A Lazy Ocaml Version</a></h3>
 <div class="content"><P>Not sure what the space complexity here is.  Also, I'm not sure I'm being as lazy as I could be (pun intended)- I may be forcing some calculations unnecessarily.  But here's the code (this should be the same solution as the Haskell code):
<PRE>
type 'a t =
    | List of 'a * 'a t Lazy.t

let rec scale n = function
    | List (h, t) -> List((h * n), lazy (scale n (Lazy.force t)))
;;

let rec merge x y =
    match x, y with
        | List(xh, xt), List(yh, yt) ->
            if xh == yh then
                List(xh, lazy (merge (Lazy.force xt) (Lazy.force yt)))
            else if xh &lt; yh then
                List(xh, lazy (merge (Lazy.force xt) y))
            else
                List(yh, lazy (merge x (Lazy.force yt)))
;;

let rec seq = List(1, lazy (merge (scale 2 seq) 
                           (merge (scale 3 seq) (scale 5 seq))));;

let hamming n = 
    let rec loop i accu = function
        | List(h, t) ->
            if i &lt; n then
                loop (i+1) (h :: accu) (Lazy.force t)
            else
                List.rev (h :: accu)
    in
    loop 1 [] seq
;;
</PRE></P></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Mon, 04/04/2005 - 23:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5274"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5274" class="active">This is an O(N) solution</a></h3>
 <div class="content"><P>I instrumented the code above to count how many times merge and scale are called to calculate the nth Hamming number.  Here's my results:
<TABLE BORDER=1><THEAD><TD>N</TD><TD>scale calls</TD><TD>merge calls</TD></THEAD><TBODY><TR><TD>2</TD><TD>3</TD><TD>2</TD></TR>
<TR><TD>4</TD><TD>5</TD><TD>5</TD></TR>
<TR><TD>8</TD><TD>10</TD><TD>11</TD></TR>
<TR><TD>16</TD><TD>24</TD><TD>26</TD></TR>
<TR><TD>32</TD><TD>53</TD><TD>56</TD></TR>
<TR><TD>64</TD><TD>121</TD><TD>118</TD></TR>
<TR><TD>128</TD><TD>267</TD><TD>243</TD></TR>
<TR><TD>256</TD><TD>577</TD><TD>495</TD></TR>
<TR><TD>512</TD><TD>1226</TD><TD>1002</TD></TR>
<TR><TD>1024</TD><TD>2573</TD><TD>2021</TD></TR>
<TR><TD>2048</TD><TD>4951</TD><TD>4051</TD></TR>
<TR><TD>4096</TD><TD>7312</TD><TD>7985</TD></TR>
<TR><TD>8192</TD><TD>11408</TD><TD>16177</TD></TR>
</TBODY></TABLE></P>

<P>This looks to me like an O(N) solution.</P></div>
 <div class="links">By <a href="user/1625" title="View user profile.">bhurt-aw</a> at Tue, 04/05/2005 - 13:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5267"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5267" class="active">Another way to approach C++</a></h3>
 <div class="content"><p >It occurred to me that the Haskell code is, to look at it imperatively, specifying each new element of the list in terms of three stateful "cursors" that move down the list.  So, if the goal is to write a solution of that runtime order in C++, one can make the list a vector (a list would work too, but it would mean more typing), and sort of encapsulate the state in a struct, and...</p>
<pre >
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;
typedef long long foo_t;

struct bar { 
  vector&lt;foo_t&gt;&amp; v; mutable int i; int m;
  operator foo_t() const { return v[i]*m; }
  foo_t operator++(int) const { foo_t r=*this; ++i; return r; }
  bar(vector&lt;foo_t&gt;&amp; iv, int im):v(iv),i(0),m(im) { }
};

int main() {
  vector&lt;foo_t&gt; s(1,1);  foo_t q;
  bar x(s,2), y(s,3), z(s,5);
  while(s.back()&gt;0) {
    cout &lt;&lt; s.back() &lt;&lt; '\n';
    do q=min(x,min(y,z))++; while(q==s.back());
    s.push_back(q);
  }
}
</pre><p >
Not that that's hugely idiomatic (and the mutable is a little evil; perhaps I've been reading too many <a href="http://www.ioccc.org/main.html">IOCCC</a> winners lately) but my point, such as there is one, is that it's basically the same algorithm as the "obvious" Haskell solution, done imperatively in C++ without too many (necessary) contortions.</p>
<p >And it's not particularly harder to "target" plain C that way, either. And go back to a linked list for simplicity's sake, and reclaim unused storage... and then sadistically fiddle with the flow control and formatting, because I <em >have</em> been reading too much IOCCC code, and:</p>
<pre >
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef long long foo_t;
#define PR_foo "%lld"

int main() {
  struct c { foo_t a; struct c*d; } *o=malloc(sizeof*o),
  *t=o; struct { foo_t m,n; struct c*b; } *w,x,y,z; w=&amp;x;
  x.m=x.n=2; y.m=y.n=3; z.m=z.n=5; (x.b=y.b=z.b=o)-&gt;a=1;
  goto harmful; while(o-&gt;a&gt;0) {
    w-&gt;n=w-&gt;m*(w-&gt;b=w-&gt;b-&gt;d)-&gt;a; if (w==&amp;z) free(t);
    t=z.b; w=x.n&lt;y.n?&amp;x:&amp;y; w=z.n&lt;w-&gt;n?&amp;z:w; harmful:
    if (o-&gt;a==w-&gt;n) continue; printf(PR_foo"\n",o-&gt;a);
    (o-&gt;d=malloc(sizeof*o))-&gt;a=w-&gt;n; o=o-&gt;d; } return 0; }
</pre><br ></div>
 <div class="links">By <a href="user/1798" title="View user profile.">Jed Davis</a> at Tue, 04/05/2005 - 05:56 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5275"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5275" class="active">back to the drawing board</a></h3>
 <div class="content"><blockquote>It occurred to me that the Haskell code is, to look at it
imperatively, specifying each new element of the list in terms of three stateful
"cursors" that move down the list. So, if the goal is to write a solution of
that runtime order in C++, one can make the list a vector, and sort of
encapsulate the state in a struct, and...
</blockquote>

<p>We have now come full circle. The above is essentially the original solution
proposed by Dijkstra, the one that the article describes as <em>"much faster but
fairly tricky"</em>.  I didn't include the corresponding code listing in the <a
href="/node/view/608#main">original post</a> to save space.
</p>

<p>So yes, you <em>can</em> implement an efficient solution in C++.  However,
efficiency was not the article's primary consideration.  The article intended to
defend C++ against claims by the FP community that there was no <em>elegant</em>
C++ solution comparable in speed and simplicity to, say, the Haskell
implementation.  The article attempted to share the authors' <a
href="http://www.google.de/search?hl=de&q=%22Aha-Erlebnis%22">Aha-Erlebnis</a>
that there is, in fact, a C++ solution that is
</p>

<ul>

  <li>quite elegant because <em>"it is hard to imagine a program that follows
   more accurately our original statement of the problem"</em>;</li>

  <li><p>only slightly less time-efficient than the Haskell solution (it's
     <em>O(n*log(n))</em> versus <em>O(n)</em> in the Haskell version);</p>
  </li>

  <li><p>written in <em>"idiomatic C++"</em> and thus does not require <em>"a
   totally different way of thinking"</em>.</p> </li>

</ul>

<p>In light of this, the article claims, the Hamming problem can no longer be
held up as a shining example of the alleged superiority of the functional
paradigm.
</p>

<p>However, the article fails to address the following points:
</p>

<ol>

  <li><p>It hides the clunkiness of the <a href="/node/view/608#comment-5130">fully
    fleshed out implementation</a> by only listing a mere four-line outline
    of the main idea.</p>

    <p>If the article were to provide a full implementation, it would have
     become obvious that, as Scott Turner <a
     href="/node/view/608#comment-5121">pointed out</a> more <a
     href="/node/view/608#comment-5160">than once</a>, the C++ version provides
     no idiomatic way to access the generated sequence.
    </p>
  </li>

  <li><p>The Haskell version is substantially <a
    href="/node/view/608#comment-5248">more space-efficient</a>.</p> </li>

  <li><p>While STL may no longer be considered <em>"a totally different way of
    thinking"</em>, it can be argued that it used to be just that when it was
    first introduced.</p> </li>

</ol>


<p>Overall, the article was a good read despite failing to support its
conclusion.
</p>
</div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Tue, 04/05/2005 - 13:41 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-5332"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5332" class="active">More efficient Haskell solutions</a></h3>
 <div class="content"><p >The thing I really like about the Haskell approach is that it feels much easier to experiment with different approaches in a delcarative setting.</p>
<p >For instance, we can observe that the given Haskell solution isn't making use of the commutativity of multiplication: the Hamming number 36 is generated five times as 2*2*3*3 and 2*3*2*3 and 2*3*3*2 and 3*2*3*2 and 3*3*2*2.</p>
<p >We could consider annotating the list of hamming numbers with their largest prime factor, to help induce an ordering on the multiplications:</p>
<pre >
-- using merge as above
scalef n xs = [ (n * x, n) | (x, m) <p >
Then we can observe that it's wasteful for 'scalef 2' to have to filter through all the hamming numbers, when it's just generating powers of two. If we stage the lists, we can omit the filtering.<br >
After a few more iterations in ghci, I arrive at:</p>
<pre >
all_multiples n (x:xs) = a where a = x : merge xs (map (n*) a)
ham3 = foldr all_multiples [1] [2,3,5]
</pre><p >
Quite a bit faster than the original, and requires less from 'merge', since it never generates duplicate numbers.</p>
<p >As a fun exercise, you can plug a 'primes' one-liner in for [2,3,5] and construct the natural numbers the hard way. :)</p>
<p >[ edited to correct identifiers ]</p></div>
 <div class="links">By <a href="user/894" title="View user profile.">Christopher Hendrie</a> at Wed, 04/06/2005 - 22:19 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-5343"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5343" class="active">Even errors in reasoning are faster the declarative way</a></h3>
 <div class="content"><p >I was sloppy in my reasoning about the redundancy in the original implementation:  each Hamming number is generated at most three times, not an arbitrarily large number of times.  I should have been suspicious when my "optimized" versions only offered a constant factor of improvement.</p>
<p >Also, all_multiples is too strict to work for regenerating the naturals from the primes.  We need a more constrained method which takes advantage of the ordering:</p>
<pre >
-- multiply_out requires that n is strictly less than (head xs)
multiply_out n xs = a where a = n : merge xs (map (n*) a)
ham4 = 1 : foldr multiply_out [] [2,3,5]

nat = 1 : foldr multiply_out [] primes
</pre><br ></div>
 <div class="links">By <a href="user/894" title="View user profile.">Christopher Hendrie</a> at Thu, 04/07/2005 - 17:42 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-5352"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5352" class="active">Minor aside</a></h3>
 <div class="content"><br >
<pre >
all_multiples n (x:xs) = a where a = x : merge xs (map (n*) a)</pre><p >
would be completely non-strict written,</p>
<pre >all_multiples n ~(x:xs) = a where a = x : merge xs (map (n*) a)</pre><p >
I'm too lazy to see if that will make it work.  On a side note, multiply_out looks broken (copy/paste error?)</p></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Fri, 04/08/2005 - 12:03 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-5355"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-5355" class="active">not strictly strict</a></h3>
 <div class="content"><p >I was perhaps, er, lazy when I used the word "strict".  What I meant was that all_multiples requires the first element of the list to be passed through from the right.  If it's being foldr'd over an infinite list, we never get the initial 1.  multiply_out solves the problem by<br >
 1) providing the tail of the list produced by all_multiples.<br >
 2) requiring that n 
It boils down to the observation that no amount of laziness will allow us to do a general infinite-way merge.  We need to impose some ordering on the heads of the lists to be merged to make it work.</p>
<p >Typo in multiply_out fixed, thanks.</p></div>
 <div class="links">By <a href="user/894" title="View user profile.">Christopher Hendrie</a> at Fri, 04/08/2005 - 16:38 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9558"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9558" class="active">A little question.</a></h3>
 <div class="content"><p >I have a little question concerning the way Haskell evaluates infinite lists. I don't understand why the Haskell algorithm is o(n) while the C++ algorithm is o(n*log(n)). How does Haskell do the computations? doesn't it have to compute all hamming numbers from 1 to N, in order to reach the Nth number? isn't C++ doing the same? </p>
<p >I understand that the Haskell algorithm uses a clever sort that actually merges two already sorted lists, while the C++ one uses binary tree algorithms (the STL set). Is that what makes the difference? or is it something else?</p>
<p >How does Haskell unites lists? doesn't it have to allocate a single linked list node in its garbage collected heap for each value?</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Wed, 09/14/2005 - 21:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9574"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9574" class="active">Anybody? please?</a></h3>
 <div class="content"><p >Please help a fellow programmer understand a little bit more your favorite programming language! :)</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Thu, 09/15/2005 - 09:30 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9585"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9585" class="active">Yes, it needs to compute N-1</a></h3>
 <div class="content"><p >Yes, it needs to compute N-1 Hamming numbers before read Nth, but it does not check for duplicates by using any O(n*logn) structure such as set or map templates.</p>
<p >Duplicates are handled in merge operation which merges two ascending lists.</p></div>
 <div class="links">By <a href="user/106" title="View user profile.">Serguey Zefirov</a> at Thu, 09/15/2005 - 19:59 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9618"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9618" class="active">Wouldn&#039;t be possible for the</a></h3>
 <div class="content"><p >Wouldn't be possible for the C++ version to use the same merge as in Haskell?</p>
<p >EDIT: Isn't the merging operation slower than using trees? </p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Fri, 09/16/2005 - 14:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9621"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9621" class="active">Yes, it is possible, because</a></h3>
 <div class="content"><p >Yes, it is possible, because GHC compiles to C. ;)</p>
<p >Yes, because you can emulate lazy evaluation.</p>
<p >And sound <b >no</b> because you wouldn't be even closer to count of lines of Haskell version. I tried that with lists with strict heads and lazy tails and I know what I am talking about.</p>
<p >Merging operation is faster that lookup operation for usual sets and maps.</p>
<p >More than that, merging of lazy lists allows you to throw away unnecessary computations on the process of computing some big hamming numbers, and you start to win in memory requirements. Or you can organize computation as memoizing, and you will start to win in speed.</p></div>
 <div class="links">By <a href="user/106" title="View user profile.">Serguey Zefirov</a> at Fri, 09/16/2005 - 15:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9630"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9630" class="active">Is the following C++ solution O(n) ?</a></h3>
 <div class="content"><pre>
template &lt class R &gt void hamming(R &r, int n) {
    r.push_back(1);
    R::iterator it = r.begin(), t;
    while (n) {
        t = it;
        t = insert_sorted(r, ++t, *it * 2);
        t = insert_sorted(r, t, *it * 3);
        insert_sorted(r, t, *it * 5);
        ++it;
        --n;
    }
}
</pre>

<p>If you can't find 'insert_sorted' in STL, don't worry; here it is(I don't consider it part of the solution since STL could have had it, if it doesn't already). It returns an iterator to the next element after the insertion point:</p>

<pre>
template &lt class R, class IT, class V &gt IT insert_sorted(R &r, IT it, V v) {
    for(; it != r.end(); ++it) {
        if (v == *it) return ++it;
        if (v < *it) return ++r.insert(it, v);
    }
    return r.insert(r.end(), v);
}
</pre>

<p>maybe the insertion process can be optimized even more by keeping track of the last inserted element and then go down or up from that.</p>

<p>It's quite elegant, though.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Fri, 09/16/2005 - 17:03 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9633"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9633" class="active">Comments</a></h3>
 <div class="content"><p >Firstly, your function does not generate the first n Hamming numbers, it can compute as many as the 3n first numbers (in general it will be less due to duplicates, of course). It would be easy enough to fix this by just checking the size of the container after each insertion.</p>
<p >Secondly, it's pretty easy to see that the "gap" insert_sorted has to traverse grows as R grows, so the algorithm certainly cannot be O(n). I'm having a hard time coming up with the exact run-time complexity but in any case it's easy to rule out O(n).</p>
<p >A quick aside: I think you need to make a few changes to make your code work with containers like std::vector because of the insertions (which will invalidate 'it' whenever resizing is forced). In its current state it should work fine with std::list (and this might be what you tested it with).</p></div>
 <div class="links">By <a href="user/1250" title="View user profile.">Per Vognsen</a> at Fri, 09/16/2005 - 17:52 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9641"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9641" class="active">Firstly, your function does n</a></h3>
 <div class="content"><p><i>Firstly, your function does not generate the first n Hamming numbers, it can compute as many as the 3n first numbers</i></p>

<p>I thought the version using sets does that too.</p>

<p><i>Secondly, it's pretty easy to see that the "gap" insert_sorted has to traverse grows as R grows, so the algorithm certainly cannot be O(n).</i></p>

<p>Yes, at each iteration the "gap" grows, so it's certainly not O(n). But the algorithm takes advantage of 2*N < 3*N < 5*N to eliminate some searches.</p>

<p>How would it be if 'insert_sorted' searched the remaining list in the reverse direction, i.e. from end to current element?</p>

<p><i>I think you need to make a few changes to make your code work with containers like std::vector because of the insertions</i></p>

<p>Yeap, it works for containers that their iterators are not invalidated when an element is inserted.</p>
</div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Sat, 09/17/2005 - 08:40 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9638"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9638" class="active">For what it&#039;s worth..</a></h3>
 <div class="content"><p >here is an O(n) C version that more or less mimics what the haskell version does (and doesn't check the return values of malloc, bad me:-)):</p>
<pre >
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

/* Production code would use a linked list implementation with a
 * less braindead allocation strategy than a malloc for every node 
 */
typedef struct node {
  long val;
  struct node *next;
} node;

/* We keep an evaluation context: a pointer to the end of the list of
 *  hamming numbers, and three pointers to the next elements of the lists of
 *  multiples, together with the next values from the lists 
 */
typedef struct context {

  node *curr;
  node *times[3];
  long val[3];
} context;

long fakt[] = {2, 3, 5};

/* The function that calculates the next hamming number for a given
 * context
 */
long hamming(context **ctx) {
  node *next;
  int i;

  next = malloc(sizeof(node));
  next-&gt;next = NULL;

  if (NULL == *ctx) {
    /* First call, initialise the context */
    
    *ctx = malloc(sizeof(context));
    next-&gt;val = 1;

    (*ctx)-&gt;curr = next;
    for (i=0; i&lt;3; ++i) {
      (*ctx)-&gt;times[i] = next;
      (*ctx)-&gt;val[i] = fakt[i];
    }
    return 1;
  } else {
    long min;

    /* Find the minimal unseen element from the three lists of multiples */
    min = (*ctx)-&gt;val[0] &lt; (*ctx)-&gt;val[1] ? (*ctx)-&gt;val[0] : (*ctx)-&gt;val[1];
    min = min &lt; (*ctx)-&gt;val[2] ? min : (*ctx)-&gt;val[2];

    next-&gt;val = min;
    (*ctx)-&gt;curr-&gt;next = next;
    (*ctx)-&gt;curr = next;

    /* Advance all lists whose next element is equal to the minimum,
     * to eliminate duplicates. The third list (times 5) gets a special
     * treatment to eliminate inaccesible nodes, the Boehm GC would make
     * this unnecessary.
     */
    for (i=0; i&lt; 2; ++i) {
      if ((*ctx)-&gt;val[i] == min) {
        (*ctx)-&gt;times[i] = (*ctx)-&gt;times[i]-&gt;next;
        (*ctx)-&gt;val[i] = (*ctx)-&gt;times[i]-&gt;val * fakt[i];
      }
    }
    if ((*ctx)-&gt;val[2] == min) {
      node *tmp;
      tmp = (*ctx)-&gt;times[2];
      (*ctx)-&gt;times[2] = (*ctx)-&gt;times[2]-&gt;next;
      (*ctx)-&gt;val[2] = (*ctx)-&gt;times[2]-&gt;val * fakt[2];
      free(tmp);
    }
    return min;
  }
}

int main(int argc, char **argv) {
  long i, m;
  context *ctx;

  ctx = NULL;
  if (argc &lt; 2) {
    m = 25;
  } else {
    m = atol(argv[1]);
    if (m &lt; 1) {
      m = 25;
    }
  }
  for (i = 1; i &lt;= m; ++i) {
    long h;
    h = hamming(&amp;ctx);
    if (h &lt; 0) {
      fprintf(stderr, "Numerical overflow at hamming number %ld.\n", i);
      exit(-1);

    }
    printf("%8ld: %16ld\n", i, h);
  }
  exit(0);
}
</pre><p >Oh, by the way, wouldn't it be nice to have the classes htmlize.el produces predifined in the CSS files?</p></div>
 <div class="links">By <a href="user/751" title="View user profile.">Florian Hars</a> at Fri, 09/16/2005 - 21:24 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9677"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9677" class="active">a long way</a></h3>
 <div class="content"><p >Undoubtedly, we've come a long way since C.  Looking at the above code and comparing to even the original posted Haskell code and you see how much along we've come in programming language design.  </p>
<p >Clearness, conciseness, expressivity...  all are missing from the above.  And no, putting short variable names in this case actually just make things even worse...</p>
<p >probably, a better approach would be just implement a Haskell compiler in C anyway? :)</p></div>
 <div class="links">By <a href="user/1328" title="View user profile.">rmalafaia</a> at Sun, 09/18/2005 - 19:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9645"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9645" class="active">Here is the C++ O(n) solution.</a></h3>
 <div class="content">And it's also an iterator.

<pre>
template &lt class T, class C = vector &lt T &gt &gt  class hamming_number {
public:
    hamming_number(int reserve) : m_v2(2), m_v3(3), m_v5(5) {
        m_vals.reserve(reserve);
        m_it = m_it2 = m_it3 = m_it5 = m_vals.insert(m_vals.end(), 1);
    }

    operator T() const {
        return *m_it;
    }

    T operator ++ () {
        T v = min3(m_v2, m_v3, m_v5);
        m_it = m_vals.insert(m_vals.end(), v);
        if (v == m_v2) m_v2 = *++m_it2 * 2;
        if (v == m_v3) m_v3 = *++m_it3 * 3;
        if (v == m_v5) m_v5 = *++m_it5 * 5;
        return v;
    }

private:
    C m_vals;
    C::iterator m_it;
    C::iterator m_it2;
    C::iterator m_it3;
    C::iterator m_it5;
    T m_v2;
    T m_v3;
    T m_v5;
};
</pre>

<p>I have to admit this though: although I understood the Haskell algorithm, I had not realized how to do it in C++ unless I looked at the C algorithm...and this is because the actual hamming algorithm is quite simple but Haskell did not gave me any clues about how to implement it in C++.</p>

<p>It's pretty simple though once you realize the fact that, at each iteration, a new hamming number is produced by calculating the minimum of 3 other numbers that are somewhere in the list of already computed hamming numbers.</p>

<p>The above code calculates the first 1000 hamming numbers in 0.000040 seconds (time measured using QueryPerformanceCounter under Win32) with all optimizations on and using a vector of 1000 numbers on an Athlon 64 3400+ using MSVC++ 6.0 (which it probably means that the Intel compiler could do an even better job).</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Sat, 09/17/2005 - 12:03 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-9650"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9650" class="active">Oz translation</a></h3>
 <div class="content"><p >It seems that it is possible to translate the Haskell code to Oz almost verbatim. Just insert some <code >lazy</code> declarations.</p>
<pre >
Scale = fun <em >lazy</em> {$ N X|Xs} N*X|{Scale N Xs} end
Merge = fun <em >lazy</em> {$ X|Xs Y|Ys}
	   if       X == Y   then  X|{Merge Xs Ys}
	   elseif   X 
Seq   = 1|{Merge {Scale 2 Seq}
	         {Merge {Scale 3 Seq} {Scale 5 Seq}}}
</strong>
</pre><br ></div>
 <div class="links">By <a href="user/1389" title="View user profile.">grzegorz</a> at Sat, 09/17/2005 - 15:55 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9663"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9663" class="active">Alice ML translation</a></h3>
 <div class="content"><p >For the sake of completeness, there's an Oz version of the Hamming functions in CTM (4.5.6) that I <a href='http://www.codepoetics.com/wiki/index.php?title=Topics:CTM_in_other_languages:Alice_ML:Chapter_4'>translated</a> to Alice ML:</p>
<pre >fun lazy scale n []      = []
  |      scale n (x::xs) = (n*x)::(scale n xs)

fun lazy merge xs nil = xs
  | merge nil ys = ys
  | merge (xs as x::xr) (ys as y::yr) =
      if x  y
               then y::(merge xs yr)
               else x::(merge xr yr)

val h = promise();
fulfill(h, 
   1 :: (merge (scale 2 (future h))
        (merge (scale 3 (future h))
               (scale 5 (future h)))));</pre><br ></div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Sat, 09/17/2005 - 21:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9674"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9674" class="active">lazy O(n) solution in C++ better than Haskell(!)</a></h3>
 <div class="content"><p>Here is a C++ solution that:</p>

<ul>
<li>it is O(n).</li>
<li>it is lazy; it can be used in loops.</li>
<li>it uses STL; there are no new classes.</li>
<li>it is only one function; it is very elegant.</li>
<li>it can use any STL collection.</li>
<li>it is sorter than the Haskell version (it can be made to be less than 3 lines by combining operations).</li>
<li>it is (at least) equally concise to the Haskell version.</li>
</ul>

<pre>
template &lt class L, class T &gt int hamming(L &l, T it[3]) {
    if (l.empty()) it[0] = it[1] = it[2] = l.insert(l.end(), 1);
    else {
        l.push_back(min(*it[0] * 2, min(*it[1] * 3, *it[2] * 5)));
        if (l.back() == *it[0] * 2) it[0]++;
        if (l.back() == *it[1] * 3) it[1]++;
        if (l.back() == *it[2] * 5) it[2]++;
    }
    return l.back();
}
</pre>

<p>Usage:</p>

<pre>
int main() {
    list &lt int &gt l;
    list &lt int &gt ::iterator it[3];
    for(int i = 0; i < 40; ++i) {
        int h = hamming(l, it);
        std::cout << h << ", ";
    }    
    return 0;
}

</pre>

<p>Output:</p>

<pre>
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144
</pre>

<p><b>I can therefore officially declare that the hamming numbers problem can no longer be used to demonstrate the superiority of functional programming languages; C++ can do it equally well.</b></p>

</div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Sun, 09/18/2005 - 17:35 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9676"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9676" class="active">Well now.</a></h3>
 <div class="content"><p >The C++ solution is inherently unsafe. (As are C++ templates and typing in general.)</p></div>
 <div class="links">By <a href="user/1447" title="View user profile.">tkatchev</a> at Sun, 09/18/2005 - 19:40 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9680"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9680" class="active">?</a></h3>
 <div class="content"><p >Please explain.</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Mon, 09/19/2005 - 04:41 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9681"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9681" class="active">The post below explained.</a></h3>
 <div class="content"><p >Templates are nothing more than string rewriting rules and do not respect typing; and without templates, the C++ type system is so weak that we need to fall back on unsafe tricks like casting to void*, etc.</p></div>
 <div class="links">By <a href="user/1447" title="View user profile.">tkatchev</a> at Mon, 09/19/2005 - 05:19 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9696"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9696" class="active">In what way...</a></h3>
 <div class="content"><p >Do templates "not respect typing"?  I thought the whole point of templates was to make type-safe macros (among other things)?</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Mon, 09/19/2005 - 17:06 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9698"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9698" class="active">Uh, no.</a></h3>
 <div class="content"><p >Templates fully respect the C++ type system; at least that any template-expanded code must respect the type system.  Templates are type-aware, as well--it just isn't a glorified text preprocessor.</p>
<p >Of course, if you do things like foo, the resulting code is not likely to be type-safe.  And C++ template code still can take full advantage of all the legacy C holes in the type system (pointer arithmetic, unchecked typecasts, returning pointers to the stack, memory management errors producing pointers to garbage).  But the template system doesn't add to the type-unsafeness of C++; if anything it improves it by providing a mechanism for building safe constructs (like vector) which are effective replacements for unsafe ones (like T[]).</p></div>
 <div class="links">By <a href="user/176" title="View user profile.">Scott Johnson</a> at Mon, 09/19/2005 - 17:38 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9716"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9716" class="active">I don&#039;t see how.</a></h3>
 <div class="content">The template system isn't any more "type-aware" than the old C macro system. It's the compiler that ultimately does the type checking over the expanded code; whereas I was talking more about something akin to structural typing or meta-types or whatever.
<P>
See Stroustrup <A HREF="http://www.research.att.com/~bs/rules.pdf">C++0x</A> where he talks about type safety, generics and so-called "concepts".
</div>
 <div class="links">By <a href="user/1447" title="View user profile.">tkatchev</a> at Tue, 09/20/2005 - 08:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9730"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9730" class="active">Hmm...</a></h3>
 <div class="content"><blockquote>The template system isn't any more "type-aware" than the old C macro system. It's the compiler that ultimately does the type checking over the expanded code; whereas I was talking more about something akin to structural typing or meta-types or whatever.</blockquote>
<p>The first sentence seems to bely some ignorance on how C++ templates work.  I absolutely reject the claim that the template system "isn't any more 'type-aware' than the old C macro system".  Tell me how the template engine can distinguish between types and values if it is type-agnostic.  Tell me how it can perform partial specialization.  Are you telling me that when I write:
<pre>
template &lt;int N&gt;
int foo() { return N; }

template &lt;int N[3]&gt;
void foo() { return N[1]; }
</pre>
That the template engine can't tell the difference?  Are you saying that this call is ambiguous?
<pre>
int main()
{
    foo&lt;3&gt;();
}
</pre>
I guarantee you that the template code above is *not* equivalent to the closest matching macro code:
<pre>
#define foo0(x) (x)
#define foo1(x) (x[1])
</pre>
Not only is x not required to be int or int[], in the second instance, x could be something that's not even an array, as long as a suitable operator[] is defined.  And saying that the compiler does the type checking makes it sound like the template engine is some disembodied ghost process that runs in some nebulous non-compiling phase, feeding its output to the "compiler proper".  Ask Daveed Vandevoorde how easy it is to separate the template engine from the rest of the compiler.  Templates are *not* some poor man's term rewrite engine.  They are not a panacea by any means, but I think they deserve a modicum of respect for what they can accomplish.
</div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Tue, 09/20/2005 - 14:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9679"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9679" class="active">Equally well?</a></h3>
 <div class="content"><p >I think I see some problems with your code. Correct me if I'm wrong.</p>
<p >Interface problems:</p>
<p >1) To compute some Hamming numbers, I need to manually supply an array of 3 iterators. Why? Isn't this an implementation detail?</p>
<p >2) The function's signature doesn't suggest that the types L and T are related.</p>
<p >3) Templates are used, but the return value of "hamming" is a plain old C int :-)</p>
<p >Implementation problems:</p>
<p >4) You're doing a lot more multiplications and comparisons than required. (Certainly more than 2 times more.)</p>
<p >5) Some code is triplicated (2,3 and 5). The constants 2,3 and 5 are each mentioned twice.</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Sun, 09/18/2005 - 20:26 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9683"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9683" class="active">1) To compute some Hamming nu</a></h3>
 <div class="content"><p><i>1) To compute some Hamming numbers, I need to manually supply an array of 3 iterators. Why? Isn't this an implementation detail?</i></p>

<p>It is an implementation detail. Supplying a list is also an implementation detail. But it is the nature of the language, and it does not matter, really.</p>

<p><i>The function's signature doesn't suggest that the types L and T are related.</i></p>

<p><i>Templates are used, but the return value of "hamming" is a plain old C int</i></p>

<p>It can be like this:</p>

<pre>
template &lt class L &gt L::value_type hamming(L &l, L::iterator it[3]);
</pre>

<p><i>You're doing a lot more multiplications and comparisons than required. (Certainly more than 2 times more.)</i></p>

<p><i>Some code is triplicated (2,3 and 5). The constants 2,3 and 5 are each mentioned twice</i></p>

<p>The number of multiplications is exactly the same as in the Haskell version. The compiler sees the same multiplications and puts them in local variables.</p>

<p>The number of comparisons is also exactly the same as in the Haskell version: at each iteration, Haskell has to compare the 3 values coming from the 3 multiplications and advance one of the 3 iterators.</p>

<p>Actually, my code is exactly the same as the C version posted above, which (the poster claims) is what Haskell does under the hood.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Mon, 09/19/2005 - 10:40 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9688"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9688" class="active">Yes, this signature is defini</a></h3>
 <div class="content"><p >Yes, this signature is definitely better.</p>
<p >The number of multiplications (and mentions of 2, 3 and 5) in source code matters just as much as the number of multiplications in the compiler output. Don't Repeat Yourself :-)</p>
<p >Also, I'm not sure you're right about the number of comparisons. You're doing them twice. Once inside the min() calls and once in the equality checks. OTOH, the Haskell version has a 3-way branch on the result of each comparison. No, this isn't a "compiler smartness" nitpick on my part - this is a "language expressivity" nitpick :-)</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Mon, 09/19/2005 - 11:12 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9689"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9689" class="active">Ah, sorry. We&#039;re talking abou</a></h3>
 <div class="content"><p >Ah, sorry. We're talking about different "Haskell versions". You must mean the one in the original post? I mean the "remarkably concise" code posted by Mark Evans - I like it more :-)</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Mon, 09/19/2005 - 11:19 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9690"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9690" class="active">You almost fooled me :-)

Y</a></h3>
 <div class="content"><p >You almost fooled me :-)</p>
<p >Your code is doing 3 multiplications on _each_ call. Too many. This is because the "next values" of iterators that fail to advance are being recomputed again and again. In Haskell, they're computed only once.</p>
<p >The compiler won't help you, unless it does memoizing :-)</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Mon, 09/19/2005 - 12:11 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9813"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9813" class="active">But isn&#039;t Haskell doing 3 mul</a></h3>
 <div class="content"><p >But isn't Haskell doing 3 multiplications at each iteration to compute some new list nodes anyway?</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Wed, 09/21/2005 - 15:55 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9886"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9886" class="active">?</a></h3>
 <div class="content"><p >Haskell computes each element of each of the 3 lazy lists exactly once. Or so I think :-)</p>
<p >Anyway you don't <i >need</i> 3*N multiplications to find N Hamming numbers. You should only need N :-)</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Thu, 09/22/2005 - 11:00 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9890"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9890" class="active">More than one for each output element</a></h3>
 <div class="content"><blockquote ><p >
Haskell computes each element of each of the 3 lazy lists exactly once. Or so I think :-)
</p></blockquote>
<p >But not every multiplication appears in the final list,<br >
as the function <code >merge</code> filters out the duplicates. You need as many multiplications for a hamming number as there are different prime numbers in its factorisation. So; 0 for 1, 1 for {2<sup >n</sup>, 3<sup >n</sup>, 5<sup >n</sup>}, 2 for {2<sup >n</sup>3<sup >m</sup>, 2<sup >n</sup>5<sup >m</sup>, 3<sup >n</sup>5<sup >m</sup>}<br >
and 3 for the others (which is the majority). For example, you need about 2500 multiplications to compute the first 1000 hamming numbers.</p>
<blockquote ><p >
Anyway you don't need 3*N multiplications to find N Hamming numbers. You should only need N :-)
</p></blockquote>
<p >Right, see <a href="http://lambda-the-ultimate.org/node/view/608#comment-5332">Christopher Hendrie's implementatation</a> our <a href="http://lambda-the-ultimate.org/node/view/608#comment-9713">mine</a> elsewhere in this thread.</p></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Thu, 09/22/2005 - 12:14 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-9925"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9925" class="active">Ah, thanks. I was confused, b</a></h3>
 <div class="content"><p >Ah, thanks. I was confused, but think I understand now.</p>
<p >axilmar's C++ version: 3*N </p>
<p >original haskell: a bit less than 3*N  (but asymptotically, I somehow feel this is 3*N again, because "degenerate" Hamming numbers are more and more rare)</p>
<p >your version: N</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Thu, 09/22/2005 - 20:00 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:200px;">
<a id="comment-9972"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9972" class="active">Back to expressivity</a></h3>
 <div class="content">This brings a question - how easy it is now to update each of these programs to report exact number of multiplications it performed before getting to this specific number?
<p>
I expect this to require just a quick dirty counter variable in C++. What about Haskell - state monad, or explicit threading of the counter?
<hr/>
[of course, I don't mean the number of prime factors of the number, but a cumulative multiplications along all search paths]</div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Fri, 09/23/2005 - 09:20 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:225px;">
<a id="comment-10102"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10102" class="active">Count multiplications</a></h3>
 <div class="content">Using a state monad or threading will serialise your computation, and you don't want that here. In this case I'd decorate the numbers with the count of multiplications that were used to compute it. You can define an instance of the <code>Num</code> class for these decorated numbers, so that you don't have to change that much to your program.
</p>

<p>
This requires a bit more thought than incrementing a  global variable at each multiplication, but I think that's because the gap between the Haskell program and its execution behaviour is greater.
</p>

<p>
This gap may be smaller in C++, but it's still there. In the C++ example you could increment a global variable at each multiplication, but perhaps the compiler eliminates the common multiplications and your count is not accurate anymore.
</p>
</div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Mon, 09/26/2005 - 08:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:250px;">
<a id="comment-10116"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10116" class="active">Non-invasive transformations</a></h3>
 <div class="content"><p >Thanks to type classes you don't need to change the function (e.g. <a href='http://lambda-the-ultimate.org/node/view/608#comment-5343'>ham4</a>, just add a type declaration <code >ham4 :: (Ord a, Num a) =&gt; [a]</code> in this case) that generates the humming numbers to be able to count the multiples. A quick and dirty implementation of such decorated number is:</p>
<pre ><code >
data N = N Integer Integer deriving (Eq, Show, Ord)
order (N _ o) = o

instance Num N where
   (N x a) + (N y b) = N (x + y) (max a b)
   (N x a) - (N y b) = N (x - y) (max a b)
   (N x a) * (N y b) = N (x * y) (a + b + 1)
   negate (N x a)    = N (negate x) a
   abs (N x a)       = N (abs x) a
   signum (N x a)    = N (signum x) a
   fromInteger       = make . fromInteger
       where make n = N n 0
</code></pre><p >
For the millionth hamming number it gives 175 multiplications.</p>
<p >It's also easy to use the same technique to collect each operand:</p>
<pre ><code >
data H = H Integer [Integer] deriving (Eq, Show, Ord)
terms (H _ ts) = ts

instance Num H where
   (H x a) + (H y b) = undefined
   (H x a) - (H y b) = undefined
   (H x a) * (H y b) = H (x * y) (a ++ b)
   negate (H x a)    = H (negate x) a
   abs (H x a)       = H (abs x) a
   signum (H x a)    = H (signum x) a
   fromInteger       = make . fromInteger
      where make n   = H n [n]
</code></pre><p >
This shows that first all 2s are computed, then 3s and finally 5s. Another implementation shows how many of each:</p>
<p ><code >2<sup >38</sup> 3<sup >109</sup> 5<sup >29</sup> = 519312780448388736089589843750000000000000000000000000000000000000000000000000000000</code>.</p></div>
 <div class="links">By <a href="user/852" title="View user profile.">Daniel Yokomizo</a> at Mon, 09/26/2005 - 15:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:250px;">
<a id="comment-10124"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10124" class="active">C++ version</a></h3>
 <div class="content">It's invasive, but it's smaller:
<pre>
class Int {
    Int(int x) : x_(x) { }
    friend int operator*(int x, Int y) { ++mults_; return x * y.x_; }
    static int mults_;
    int x_;
};
int Int::mults_ = 0;
</pre>
<p>In the C++ version, replace the constants with Int(x)  Basically 7 lines.  However, I will admit that the Haskell version does more with each line.  But at least part of that is because the language strips out all unnecessary syntax, whereas C++ takes a more conservative approach.  Also, Haskell overloads operators even more than C++ does.  And, being an FP, the intrinsic data structures are naturally richer, leading to a more concise syntax; whereas C++ elects to make anything bigger than a machine word into a library.  Finally, the biggest gains Haskell makes are due to the fact that it treats functions as first-class values, which is as one should expect.</p>
Unfortunately, I think it is too late to make C++ into an even passable FP, but I hope that Scala continues to be developed, because I think it sits in a really interesting (and I suspect very, very powerful) point in the design space.
</div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Mon, 09/26/2005 - 18:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9701"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9701" class="active">Here&#039;s a slightly better version...</a></h3>
 <div class="content"><br >
<pre >
#include &lt;iostream&gt;
#include &lt;list&gt;

template &lt;class L&gt;
typename L::value_type hamming(L &amp;l)
{
    static int const p[] = { 2, 3, 5 };
    static typename L::iterator it[3];
    if (l.empty()) it[0] = it[1] = it[2] = l.insert(l.end(), 1);
    else
    {
        typename L::value_type const f[3] = { *it[0] * p[0], *it[1] * p[1], *it[2] * p[2] };
        int const i = f[0] &lt; f[1] ? (f[0] &lt; f[2] ? 0 : 2) : (f[1] &lt; f[2] ? 1 : 2);
        l.push_back(f[i]);
        for (int i = 0; i != 3; ++i) if (l.back() == f[i]) ++it[i];
    }
    return l.back();
}

int main()
{
    std::list&lt;int&gt; l;
    std::cout &lt;&lt; hamming(l);
    for (int i = 1; i != 40; ++i)
    {
        int h = hamming(l);
        std::cout &lt;&lt; ", " &lt;&lt; h;
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}
</pre><p >This version obviously requires that operator*(typename L::value_type, int) be defined in the sensible way, as well as requiring L::value_type to be LessThanComparable and EqualityComparable, but any reasonable numeric type will need to satisfy those constraints anyway.</p>
<p >It's a bit long, but mostly that has to do with the fact that C++ template code tends to be a little verbose.</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Mon, 09/19/2005 - 19:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9682"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9682" class="active">Smooth numbers - generic Hamming</a></h3>
 <div class="content">I suggest making the task harder by requiring parametricity in primary multipliers - make 2, 3, and 5 just a special case, appearing only in the client code at the invocation/instantiation/etc. site.
<p>
Will Haskell version still be better than C++?
</div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Mon, 09/19/2005 - 08:57 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9684"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9684" class="active">Template parameters can be constants.</a></h3>
 <div class="content"><p>The 'hamming' function can be paramerized on the primary factors by using template constants. For example:</p>

<pre>
template &lt int P1, int P2, int P3, class L &gt L::value_type hamming(L &l, L::iterator it[3])
</pre>

<p>And used like this:</p>

<pre>
hamming<2, 3, 5>(l, it);
</pre>
</div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Mon, 09/19/2005 - 10:48 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9686"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9686" class="active">Errata</a></h3>
 <div class="content">Um, I didn't mean limiting the requirements to exactly three factors.
<p>
On other issue: your client code seems not using "it" in any way other than passing it into the "hamming", am I right?</div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Mon, 09/19/2005 - 10:56 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9697"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9697" class="active">You can generate...</a></h3>
 <div class="content"><p >The code to support an arbitrary number of parameters using the Boost.Preprocessor Library, but Paul Mensonides is probably the only person who could do so in an hour or less.  Of course, the arity will be limited by the limitations of the C++ preprocessor, but I'm sure you could get a fairly high number of factors.</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Mon, 09/19/2005 - 17:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9714"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9714" class="active">Phase limitation</a></h3>
 <div class="content"><p >What if I learn these factors only at runtime? That's actually my main reservation about expressive power of C++ meta-programming - the fact that it is exactly meta. I would prefer an approach that would not impose a choice of phase of evaluation on me.</p></div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Tue, 09/20/2005 - 08:15 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9737"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9737" class="active">Example?</a></h3>
 <div class="content"><p >Can you cite a real-world example of an algorithm where you know the fundamental parameters at compile time sometimes, and at runtime other times?</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Tue, 09/20/2005 - 15:05 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9744"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9744" class="active">Image loading for Games</a></h3>
 <div class="content"><p >I've seen all sorts of crazy optimizations for FPS games. I wouldn't be surprised if some people have specialized their code to know image sizes at compile time.<br ><br >
Image loading generally finds out the image size at runtime obviously.<br ><br >
I like partial application/evaluation because then I don't have to choose. (Yes, I know that only partial evaluation is compile time.)<br ><br >
--Shae Erisson - <a href="http://www.ScannedInAvian.com/">ScannedInAvian.com</a></p></div>
 <div class="links">By <a href="user/1177" title="View user profile.">shapr</a> at Tue, 09/20/2005 - 16:08 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-9814"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9814" class="active">I&#039;d be surprised if it happen</a></h3>
 <div class="content"><p >I'd be surprised if it happened now. Of course, there was a time when compiled sprites were worth using...</p></div>
 <div class="links">By <a href="user/1621" title="View user profile.">Philippa Cowderoy</a> at Wed, 09/21/2005 - 16:12 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:200px;">
<a id="comment-9872"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9872" class="active">It happens</a></h3>
 <div class="content"><p >On PC-level computers it happened a few years ago in massive "real-time" strategy game engines like Cossacks. I am possitive it still happens on lower-end devices like PDAs and mobiles.</p></div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Thu, 09/22/2005 - 07:50 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9773"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9773" class="active">Reframing</a></h3>
 <div class="content">I don't see this property as intrinsic to any algorithm. If any algorithm is to be reusable, it should not make decisions for its clients. Or, to put it another (milder) way, the more decisions you make for clients, the less clients you have.
<p>
I agree with shapr that computer games are especially prone to pushing cycles from runtime to compile time (Paul/Tim?), but in fact any application living on the edge of feasibility given the hardware and other parts of environment would do that.</div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Wed, 09/21/2005 - 08:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-9799"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9799" class="active">I Was Just Going to Observe...</a></h3>
 <div class="content"><p >... that it's dirt common in games to have huge amounts of data at game build-time that you <em >could</em> simply pump through your renderer at runtime, but you wouldn't get acceptable performance that way, so some data-driven calculations are done at build-time. For example, games tend to do "potentially visible set" (<a href="http://www.tml.tkk.fi/Opinnot/Tik-111.500/2003/paperit/MikkoLaakso.pdf">PVS</a>) calculations at build-time so as not to bother rendering polygons that wouldn't be visible to the user anyway at runtime. More recently, a great deal of work has been done in the application of partial evaluation to raytracing and to specializing complex shaders. It's interesting to note that Mark Leone, whose name is well-known in <a href="http://portal.acm.org/citation.cfm?id=989448">partial evaluation, runtime code-generation, and Standard ML</a> circles, was ultimately hired by Pixar and wrote an important <a href="http://graphics.cs.ucdavis.edu/~lefohn/work/shadingLang/mio/">paper</a> on the Multi-Pass Partitioning Problem. His name also appears in the credits of "The Incredibles."</p>
<p >Shaders are where it's at these days, and a lot of attention is being paid to functional programming and partial evaluation in the context of <a href="http://www.cgl.uwaterloo.ca/Projects/rendering/Papers/#algebra">shader algebra</a> and specialization. It would be interesting to hear from Tim how Unreal Technology 3's artist-controlled visual shader development tools do (or do not) represent a particular form of specializing shader compiler.</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Wed, 09/21/2005 - 13:31 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9785"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9785" class="active">No problem with run-time parameterization.</a></h3>
 <div class="content"><p >The function would become:</p>
<pre >
template  L::value_type hamming(L &amp;l, vector  &amp;it, const vector   facts);
</pre><p >
The code will use the supplied vector of iterators and factors, and use for-loops inside the code to perform the computation.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Wed, 09/21/2005 - 11:21 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-9725"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9725" class="active">Paul Mensonides is probably t</a></h3>
 <div class="content"><p ><i >Paul Mensonides is probably the only person who could do so in an hour or less.</i></p>
<p >No disrespect to Paul, but if you can afford to use a C99 preprocessor, anyone who knows FP should be able to write the generator in a matter of minutes using the Order interpreter. See <a href="http://cvs.sourceforge.net/viewcvs.py/chaos-pp/order-pp/example/">here</a> for examples. (For the record, given a choice, I wouldn't use C++. I have given up on C++.)</p></div>
 <div class="links">By <a href="user/2285" title="View user profile.">Vesa Karvonen</a> at Tue, 09/20/2005 - 12:13 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9731"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9731" class="active">Order vs. Chaos</a></h3>
 <div class="content"><p >Heh.  This debate always sounds like the fate of the universe hangs in the balance of some preprocessor metaprogramming libraries (PMLs). ;&gt;  One thing that the existence of PMLs has convinced me of is that there must be a better way. ;)  That better way, I think, is a language that allows you to jump levels of abstraction seamlessly, like Lisp/Scheme, but within an imperative/static typing context, which is probably about as painful and difficult to implement as it sounds.  I sympathize with your sentiments re: C++.  I think it's a fine language in some respects, and I think it deserves some respect for the areas in which it broke ground; but I fear that true progress can only be had by starting fresh.  With no disrepect to Paul or the other Boost.PP lib authors, my comment is as much a commentary on the Boost.PP lib as it is a compliment to Paul's skills.</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Tue, 09/20/2005 - 14:47 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-9758"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9758" class="active">Order-PP</a></h3>
 <div class="content"><p >I haven't seen Order before. I'd appreciate better links if there are any. Looks cool!</p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Tue, 09/20/2005 - 21:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-9782"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9782" class="active">Order-PP was my hobby project</a></h3>
 <div class="content"><p >I don't think that there are considerably better links than the examples at SF. Order was my hobby project for some time, but, like I said, I have given up on C++ (meaning: I try very hard to avoid wasting any more time with C++).</p>
<p >The roots of Order can be traced back to this <a href="http://lists.boost.org/Archives/boost/2003/04/46645.php">post</a>. After that I switched to a C99 preprocessor and discovered several improvements, which improved performance (in some important cases) by two orders of magnitude and made interpretation "practical" in some sense. I spent one summer to make an implementation of the Order language culminating in this <a href="http://lists.boost.org/Archives/boost/2004/09/71599.php">post</a>. Since then I have come to the conclusion that I don't want to waste more time with C++ and the Order project is (consequently) on hold. The actual Order interpreter is basically finished (just checkout the code from SF CVS). Documentation (except for the examples) is <a href="http://cvs.sourceforge.net/viewcvs.py/chaos-pp/order-pp/doc/tom/tom.ltx?view=markup">incomplete</a>.</p></div>
 <div class="links">By <a href="user/2285" title="View user profile.">Vesa Karvonen</a> at Wed, 09/21/2005 - 11:01 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-9798"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9798" class="active">Thanks</a></h3>
 <div class="content"><p >Thanks</p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Wed, 09/21/2005 - 13:23 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9694"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9694" class="active">Ok, let me try the Haskell version.</a></h3>
 <div class="content"><p>If no one else does it, let me try my first Haskell program:</p>
<pre>merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys)
    | x == y    = x : merge xs ys
    | x <  y    = x : merge xs (y:ys)
    | otherwise = y : merge (x:xs) ys

ham factors = seq
  where
    seq = 1 : (foldr mergeScaled [] factors)
    mergeScaled n xs = merge xs (map (n*) seq)</pre>
<p>First timer issue: I find it odd that the arguments to mergeScaled have to be <code>n xs</code>, when the order in foldr is <code>[] factors</code>.</p>
<p>I also tried an imperative version in Javascript. It was telling that getting the Javascript version right was harder than getting the Haskell version right, while this was my first Haskell program, and I program in JS daily.</p></div>
 <div class="links">By <a href="user/175" title="View user profile.">sjoerd_visscher</a> at Mon, 09/19/2005 - 14:36 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9713"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9713" class="active">Smoothies</a></h3>
 <div class="content"><p >You can generate the p<sub >n+1</sub>-smooth numbers from the p<sub >n</sub>-smooth numbers by mixing in p<sub >n+1</sub> (p<sub >n</sub> being the n<sup >th</sup> prime):</p>
<pre >
smooth :: [Integer] -&gt; [Integer]
smooth l@(h:t) = next
    where
        p = missing  l
        next = h : merge (map (* p) next) t
</pre><p >
The function missing finds the first gap in the previous smooth sequence, which is the next prime.</p>
<pre >
missing :: [Integer] -&gt; Integer
missing l@(_:t) = head [n+1 | (n,m) <p >
Now we can generate all smooth sequences by iterating over the 2-smooth sequence (the powers of 2):</p>
<pre >
smoothies :: [[Integer]]
smoothies = iterate smooth (iterate (* 2) 1)
</pre><p >
For example the hamming sequence (5-smooth) is the<br >
third element from this list, so the following test function should not terminate.</p>
<pre >
test = smoothies !! 2 == ham
</pre><p >
Interestingly enough the more general version is almost twice as fast as the direct version, but I have yet to figure out why.</p>
<p >We now also have a odd way to generate the odd primes:</p>
<pre >
oddPrimes :: [Integer]
oddPrimes = map missing smoothies
</pre><br ></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Tue, 09/20/2005 - 06:58 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9715"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9715" class="active">An unexpected bonus</a></h3>
 <div class="content"><blockquote ><p >
Interestingly enough the more general version is almost twice as fast as the direct version, but I have yet to figure out why.
</p></blockquote>
<p >It would be nice to know whether it is just a quirk of the compiler, or a genuine improvement of algorithm. If we only had compilers inferring algorithmic complexity for us (say as a part of type inference process)...</p></div>
 <div class="links">By <a href="user/1071" title="View user profile.">Andris Birkmanis</a> at Tue, 09/20/2005 - 08:20 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9721"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9721" class="active">No duplicate composites</a></h3>
 <div class="content"><p >The general version is faster because it doesn't generate any duplicate composites. The corresponding specialised hamming function is:</p>
<pre >
ham = c5
    where
        c2 = 1 : map (* 2) c2
        c3 = 1 : merge (map (* 3) c3) (tail c2)
        c5 = 1 : merge (map (* 5) c5) (tail c3)
</pre><p >
Because the algorithm doesn't generate duplicates, the following <code >merge</code> function suffices:</p>
<pre >
merge (x:xs) (y:ys)
    | x <br ></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Tue, 09/20/2005 - 09:44 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9687"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9687" class="active">Conclusion</a></h3>
 <div class="content"><p >I suspect that any lazy functional algorithm can be translated to an imperative one by using these simple rules:</p>
<p >1) a lazy algorithm can be encoded as an imperative function which transforms some input according to some computation.</p>
<p >2) the imperative implementation needs 1 collection and a number of iterators equal to the number of references of the lazy function in the right side of the equation. For example, the Haskell version mentions 'hamming' 3 times at the right hand side, so 3 iterators are needed for the imperative algorithm.</p>
<p >The above is from intuition, I must say.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Mon, 09/19/2005 - 10:59 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9702"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9702" class="active">&quot;Why Functional Programming Matters&quot;</a></h3>
 <div class="content"><p >The above named paper is a rather old paper (but a still a good read), but has some more complicated examples using lazy evaluation that you could use to test your hypothesis.  Particularly section 5 which implements the alpha-beta heuristic.</p>
<p ><a href="http://www.md.chalmers.se/~rjmh/Papers/whyfp.pdf">Why Functional Programming Matters</a></p></div>
 <div class="links">By <a href="user/1510" title="View user profile.">Derek Elkins</a> at Mon, 09/19/2005 - 19:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9706"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9706" class="active">Original LtU discussion</a></h3>
 <div class="content"><p ><a href="http://lambda-the-ultimate.org/classic/message10106.html">here</a></p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Mon, 09/19/2005 - 20:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9717"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9717" class="active">Ugh.</a></h3>
 <div class="content"><p >That papers really irks me.</p>
<p >While it proposes a nice list of hacks, this sort of thing will not impress anybody who does industrial programming. Quite the contrary, I think.</p></div>
 <div class="links">By <a href="user/1447" title="View user profile.">tkatchev</a> at Tue, 09/20/2005 - 08:32 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9719"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9719" class="active">Tried something like that, but didn&#039;t really work (yet)</a></h3>
 <div class="content"><p>
I tried an OCaml solution to the Hamming problem. It is listed below.
</p><p>
It uses a small trick with a continuation/coalgebraic flavor. An infinite lazy sequence can be modelled as a datatype which consists of a head, and a tail function with will give the next head and the next tail function.
</p><p>
It's my first ten minutes try, it doesn't work for large lists. Probably there is some reevaluation taking place (no sharing?) - will look at it again at some point.
</p><p>
Anyway, here's the code; please spot the bug ;-)
</p>
<pre>
<font color="#0000CC">type</font> num <font color="#0000CC">=</font> <font color="#00ff00">int</font>

<font color="#0000CC">type</font> clist <font color="#0000CC">=</font> <font color="#CC0000">H</font> <font color="#0000CC">of</font> <font color="#0000CC">(</font>num <font color="#0000CC">*</font> <font color="#0000CC">(</font><font color="#00ff00">unit</font> <font color="#0000CC">-&gt;</font> clist<font color="#0000CC">))</font>
<br/>
<font color="#0000CC">let</font> <font color="#0000CC">rec</font> merge: clist <font color="#0000CC">-&gt;</font> clist <font color="#0000CC">-&gt;</font> clist <font
color="#0000CC">=</font>
   <font color="#0000CC">function</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>x, fx<font color="#0000CC">)</font> <font color="#0000CC">-&gt;</font> <font color="#0000CC">function</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>y,fy<font color="#0000CC">)</font> <font color="#0000CC">-&gt;</font>
   <font color="#0000CC">if</font> x <font color="#0000CC">&lt;</font> y <font color="#0000CC">then</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>x, <font color="#0000CC">function</font> <font color="#0000CC">_</font> <font color="#0000CC">-&gt;</font> merge <font color="#0000CC">(</font>fx<font color="#CC0000">()</font><font color="#0000CC">)</font> <font color="#0000CC">(</font><font color="#CC0000">H</font><font color="#0000CC">(</font>y,fy<font color="#0000CC">)))</font>
   <font color="#0000CC">else</font> <font color="#0000CC">if</font> x <font color="#0000CC">==</font> y <font color="#0000CC">then</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>x, <font color="#0000CC">function</font> <font color="#0000CC">_</font> <font color="#0000CC">-&gt;</font> merge <font color="#0000CC">(</font>fx<font color="#CC0000">()</font><font color="#0000CC">)</font> <font color="#0000CC">(</font>fy<font color="#CC0000">()</font><font color="#0000CC">))</font>
   <font color="#0000CC">else</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>y, <font color="#0000CC">function</font> <font color="#0000CC">_</font> <font color="#0000CC">-&gt;</font> merge <font color="#0000CC">(</font><font color="#CC0000">H</font><font color="#0000CC">(</font>x,fx<font color="#0000CC">))</font> <font color="#0000CC">(</font>fy<font color="#CC0000">()</font><font color="#0000CC">))</font>

<font color="#0000CC">let</font> <font color="#0000CC">rec</font> scale: num <font color="#0000CC">-&gt;</font> clist <font color="#0000CC">-&gt;</font> clist <font color="#0000CC">=</font>
   <font color="#0000CC">function</font> s <font color="#0000CC">-&gt;</font> <font color="#0000CC">function</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>x, fx<font color="#0000CC">)</font> <font color="#0000CC">-&gt;</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>s <font color="#0000CC">*</font> x, <font color="#0000CC">function</font> <font color="#0000CC">_</font> <font color="#0000CC">-&gt;</font> scale s <font color="#0000CC">(</font>fx<font color="#CC0000">()</font><font color="#0000CC">))</font>

<font color="#0000CC">let</font> <font color="#0000CC">rec</font> hamming: clist <font color="#0000CC">=</font>
   <font color="#CC0000">H</font><font color="#0000CC">(</font><font color="#CC0000">1</font>, <font color="#0000CC">function</font> <font color="#0000CC">_</font> <font color="#0000CC">-&gt;</font> merge <font color="#0000CC">(</font>scale <font color="#CC0000">2</font> hamming<font color="#0000CC">)</font> <font color="#0000CC">(</font>merge <font color="#0000CC">(</font>scale <font color="#CC0000">3</font> hamming<font color="#0000CC">)</font> <font color="#0000CC">(</font>scale <font color="#CC0000">5</font> hamming<font color="#0000CC">)))</font>

<font color="#0000CC">let</font> <font color="#0000CC">rec</font> print_clist: num <font color="#0000CC">-&gt;</font> clist <font color="#0000CC">-&gt;</font> <font color="#00ff00">unit</font> <font color="#0000CC">=</font>
  <font color="#0000CC">function</font> n <font color="#0000CC">-&gt;</font> <font color="#0000CC">function</font> <font color="#CC0000">H</font><font color="#0000CC">(</font>x,fx<font color="#0000CC">)</font> <font color="#0000CC">-&gt;</font>
  <font color="#0000CC">if</font> n <font color="#0000CC">=</font> <font color="#CC0000">0</font> <font color="#0000CC">then</font> print_newline <font color="#CC0000">()</font> <font color="#0000CC">else</font>
    <font color="#0000CC">(</font>print_int n<font color="#0000CC">;</font> print_string <font color="#CC0000">&quot; : &quot;</font><font color="#0000CC">;</font> print_int x<font color="#0000CC">;</font> print_newline <font color="#CC0000">()</font><font color="#0000CC">;</font> print_clist <font color="#0000CC">(</font>n-<font color="#CC0000">1</font><font color="#0000CC">)</font> <font color="#0000CC">(</font>fx<font color="#CC0000">()</font><font color="#0000CC">))</font>

<font color="#0000CC">let</font> <font color="#0000CC">_</font> <font color="#0000CC">=</font> print_clist <font color="#CC0000">1000</font> hamming




</pre>
<p>
[Edit: hmm, might be because I de/reconstruct all the H-fields]
</p>
<p>
[Edit the edit: can't be it, either I am explicitly copying -am I?- or ocaml doesn't have a true graph rewriting semantics -does it?- which would make sense I guess...]
</p>
</div>
 <div class="links">By <a href="user/1360" title="View user profile.">marco</a> at Tue, 09/20/2005 - 09:00 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9741"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9741" class="active">&quot;some&quot; reevaluation...</a></h3>
 <div class="content"><p >Your evaluation order is busy, rather than lazy, it reevaluates everything, all the time, try </p>
<pre >
<b >let</b> <b >rec</b> scale: num -&gt; clist -&gt; clist =
   function s -&gt; function H(x, fx) -&gt; 
     Printf.fprintf stderr "Evaluating %d * %d\n" s x;
     H(s * x, function _ -&gt; scale s (fx()))
</pre><p >
You should change your lazy list to</p>
<pre >
<b >type</b> clist = H of (num * clist Lazy.t)
</pre><p >and sprinkle your code with magic pixie dust the approriate lazy and Lazy.force statements.</p></div>
 <div class="links">By <a href="user/751" title="View user profile.">Florian Hars</a> at Tue, 09/20/2005 - 15:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-9775"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9775" class="active">Great</a></h3>
 <div class="content"><p >Thanks for the heads-up. Yeah, I know you can do it like that. But that wasn't really the point of the exercise: I wanted to try and do it <em >without</em> the lazy keyword...</p></div>
 <div class="links">By <a href="user/1360" title="View user profile.">marco</a> at Wed, 09/21/2005 - 09:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-9793"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9793" class="active">C++ solution on par with Haskell</a></h3>
 <div class="content"><p>Here is another way to do it in C++ using lazy lists:</p>

<pre>
list &lt int &gt hamming = val(1) >> next(min(2*hamming >> 3*hamming >> 5*hamming));
</pre>

<p>The list would be used like this:</p>

<pre>
iterator < int > it = hamming;
for(int i = 0; i < 40; i++) {
    cout << it() << ",";
    it = tail(it);
}
</pre>

<p>Notes:</p>

<ul>
<li>the <code>operator >></code> is used to define a cons of lazy expressions.</li>
<li>the <code>val</code> function returns a functor that, when evaluated, it will return the given value.</li>
<li>each reference to <code>hamming</code> at the right side of the equation creates one iterator instance which is initialized to point to the first element of the list when the object <code>hamming</code> is constructed.</li>
<li>The <code>operator *</code> between a number and a lazy iterator would return a pair of {value * value of iterator, iterator} when evaluated. </li>
<li>The <code>operator >></code> between {value, iterator} pairs would create a temporary array of the pairs.</li>
<li>The <code>min</code> function would scan the given array of {value, iterator} pairs and would return an array of references to iterators that contain the iterators that belong to pairs that their values are equal to the minimum of the values of the pairs.</li>
<li>the <code>next</code> function would create a new list node that would be the next node of the current node contained in the iterator <code>it</code>; the value of the node would be the value of the first iterator contained in the array that is the result of <code>min</code>; the iterators contained in the result of <code>min</code> would be set to point to the next element.</li>
<li>The first <code>tail(it)</code> would set the internal pointer of <code>it</code> to point to the next lazy element of <code>hamming</code>.</li>
<li>The subsequent invocations of <code>tail(it)</code> would create the next hamming value by invoking the lazy expression created above.</li>
</ul>

<p>The above can be used in any lazy list. For example, the Fibonacci sequence would be defined as:</p>

<pre>
list < int > fib = val(0) >> val(1) >> next(fibs + tail(fibs));
</pre>

<p>The above formula would create two iterators (since there are two fibs references at the right side of the formula). Initially, both iterators would point to value 0. At the third extraction, the new value would be the value of iterator 1 (0) to the value of the next element of iterator 2 (value 1). The function 'next' would be used to advance the iterators passed to it to their next element.</p>

<p>EDIT:</p>

<p>Yeap, it can be done, thanks to C++ operator overloading. So the hamming algorithm can be done better in C++ than in Haskell...in just one line of code!</p>
</div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Wed, 09/21/2005 - 12:24 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-9835"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9835" class="active">One line of code?</a></h3>
 <div class="content"><blockquote ><p >So the hamming algorithm can be done better in C++ than in Haskell...in just one line of code!</blockquote>
One line of code? What about all the lines of code to implement <code >operator *</code>, <code >operator &gt;&gt;</code>, <code >val</code>, <code >min</code>, etc? It seems to me that you end up implementing a crippled version of a subset of Haskell in order to achieve your "one line of code". I'm reminded of <a href="http://en.wikipedia.org/wiki/Lisp_programming_language#Quotations">Greenspun's  10th Rule of Programming</a>.</p></div>
 <div class="links">By <a href="user/1670" title="View user profile.">Allan McInnes</a> at Wed, 09/21/2005 - 18:45 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-9878"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-9878" class="active">Indeed, I implemented some su</a></h3>
 <div class="content"><p>Indeed, I implemented some subset of Haskell (along with some hacks), just to show that it can be done. Aside from being a cool hack, the code can be reused for doing any kind of lazy lists.</p>

<p>Of course since Haskell is available, there is no point in using C++ as Haskell...but it is a nice exercise anyway.</p>

<p>By the way, I think it is possible to do it exactly like in Haskell with complete lazy evaluation, and writing the merge function as a functor object, like this:</p>

<pre>
fun2 merge = _if(_1 == _2, merge(tail(_1), _tail(_2)))
           | _if(_1 < _2, _1 >> merge(_1, _tail(_2))
           | _2 >> merge(_tail(_1), _2);
</pre>

<p>The above functor object would return an operation object that would be attached to the list and evaluated when needed.</p>
</div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Thu, 09/22/2005 - 09:35 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-10106"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10106" class="active">You&#039;re kidding, right?</a></h3>
 <div class="content"><p >Yeah, right. We're pretty close to expression trees and an evaluator... the next step would be a parser and interpreter.</p>
<p >I'm already waiting for somebody who'd advocate "idiomatic Java" for the same task:</p>
<p >Function merge = new BinaryFunction(new Branch(new Case(new EqualCondition(Parameter.FIRST, Parameter.SECOND), ...et cetera, ad nauseam... and we get garbage collection for free!</p>
<p >Surely there's got to be a limit somewhere. For me, the limit is simple: Don't Write Bad Code. The code you supplied is so obviously Bad, I'm embarrassed even to have to explain it.</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Mon, 09/26/2005 - 10:51 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-10146"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10146" class="active">Your reaction is understandable.</a></h3>
 <div class="content"><p >After all, C++ is the devil for LtU members. But the truth is, since C++ allows operator overloading and value type objects, a lazy library can easily be written that does exactly what Haskell does and with the same expressitivity.</p>
<p >And your Java example is simply wrong, because what makes the hamming algorithm be beautiful it is the way  it is expressed using operators. Since Java lacks operator overloading, it can not be considered equal in expressitivity.</p>
<p >So there has got to be a limit somewhere. For me, the limit is simple: don't say stupid things. The example you supplied is so stupid, I am embarrassed even to have to write about it.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Tue, 09/27/2005 - 10:23 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-10153"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10153" class="active">I have to agree</a></h3>
 <div class="content">That operator overloading was one of the smartest things Bjarne added to C++.  Yes, yes, it's "just" syntactic sugar, but we are used to seeing and reading symbols, especially when they are a powerful shorthand for important concepts.  Imagine if we taught schoolchildren to do math like so:
<pre>
       four
  add  four
equals eight
</pre>
<p>It's pretty much exactly equivalent to the usual notation, except that it's much harder for us to read, not at least partly because it's so verbose.  I'm sure part of what makes Haskell so appealing to some programmers is how concise it is.  And it achieves much of that syntactic parsimony through the heavy use of symbols.  A more verbose Ada-like dialect of Haskell where all the symbols are replaced by word tokens would probably cause FP programmers to recoil in horror.</p>
<p>I would argue that choosing to *not* include operator overloading was one of the biggest failures of Java's design, and is why it would be utter folly to even attempt to implement half the libraries that exist for C++, including Spirit++, Blitz++, Boost.Iterator, etc.  Sometimes I look upon libraries like Boost.Lambda with a combination of admiration and loathing, but you have to admit that for a 20 year old statically typed imperative PL, C++ does all right for itself.</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Tue, 09/27/2005 - 14:38 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-10165"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10165" class="active">Hmmm...</a></h3>
 <div class="content"><blockquote ><p >A more verbose Ada-like dialect of Haskell where all the symbols are replaced by word tokens would probably cause FP programmers to recoil in horror.</p></blockquote>
<p >You mean like Scheme...?  ;)</p></div>
 <div class="links">By <a href="user/431" title="View user profile.">Matt Hellige</a> at Tue, 09/27/2005 - 17:39 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-10156"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10156" class="active">Beauty is in the eye of the beholder</a></h3>
 <div class="content"><p >I'm all for judicious use of operator overloading, but I think it a mistake to assume that the elegance of the Haskell code is due to operators.  The use of operators in the Haskell code is pretty bare minimum and there's nothing particularly out of the ordinary for those that are used ([] : * = == <br ></p>
<p >So the question back is why is the Haskell code considered elegant?  FWIW, the Oz code and the Alice ML code are fairly close to the Haskell code, so perhaps the answer is not the Haskell Type system.  For sure, you have to have lazy functions.  (IMHO, any solution that uses iteration and array pointers misses the whole point to the elegance of the recursion).<br ><br ></p>
<p >As an aside, APL has always been on the extreme in terms of usage of operators.  For those that understand the symbols, APL provides a power for manipulation that is as expressive as any language.  For those that don't understand the symbols, APL can look like chicken scratch.  The biggest problem with APL is that you can't define new operators that act in a first class fashion.<br ><br ></p>
<p >The use of symbols in code can sometimes aide readibility.  It can also sometimes make it harder to grok.  Not particularly caring about C++ at this juncture in history, I find it weird that the use of such symbols as &gt;&gt; and</div>
 <div class="links">By <a href="user/3" title="View user profile.">Chris Rathman</a> at Tue, 09/27/2005 - 15:11 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-10211"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10211" class="active">Syntactic brevity</a></h3>
 <div class="content"><blockquote ><p >The use of operators in the Haskell code is pretty bare minimum and there's nothing particularly out of the ordinary for those that are used ([] : * = == </blockquote>
<p >In that example, although Haskell uses a lot more symbols than that.  But perhaps another major source of conciseness is the type inference.  That takes a *lot* of identifiers out of the code that you find in manifestly typed languages.</p>
<blockquote ><p >The use of symbols in code can sometimes aide readibility. It can also sometimes make it harder to grok.</p></blockquote>
<p >Can we say: "awk/sed"?</p>
<blockquote ><p >Not particularly caring about C++ at this juncture in history, I find it weird that the use of such symbols as &gt;&gt; and </blockquote>
<p >Well, I've never understood this criticism of C++.  If you want to concatenate stream operations, you need to have a stream operator.  Was there some de facto stream operator before ?  It makes perfect sense to me, since most *nix shells use &gt; and .</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Tue, 09/27/2005 - 21:29 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-10188"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10188" class="active">Expressivity</a></h3>
 <div class="content"><p >I was way too harsh and vague in my comment about "bad code". Excuse me, I'll try not to do this in the future.</p>
<p >I'll try to explain my point in some more detail, if you're still listening...</p>
<p >I easily grant that, given any concrete task, C++ can be made as expressive as Haskell for this task, by writing a (quite large) supporting combinator library (operator overloading and expression templates to build/evaluate syntax trees).</p>
<p >But the "bad code" I blurted out isn't just an expressivity measure. The criterion of "good code" I have developed over the years is as follows: good code should be right, and it should be <i >obviously</i> right.</p>
<p >Of course, there are different grades of "obviously", so it's a very subjective metric. But the experience of many people shows that it's VERY hard to write "obviously right" code in C++.</p>
<p >For a quick mental test, look back at the code you supplied (_if, _1, _2 and stuff). Imagine debugging/maintaining just a couple hundred lines of such code, freely mixed with "normal" C++ and - for kicks - also using some other expression-template combinator library (e.g. Boost Spirit).</p>
<p >I can easily imagine working with tasks of similar complexity in Haskell - though I'm a Haskell newbie at best.</p>
<p >And no, operator overloading isn't the biggie here. It's just syntax.</p>
<p >For example: you alluded to my mock Java sample as "stupid", but... dont' you think that, if you're embedding a functional language within C++, you're going to need a garbage collector at some point? Yes, value types help, but they don't solve all problems. OCaml has a GC. Haskell has a GC. And even Java has a GC... so my example wasn't so stupid after all :-)</p>
<p >See? This <i >semantic</i> issue is much more important than the <i >syntax</i> issue (operator overloading) you pointed out.</p></div>
 <div class="links">By <a href="user/2277" title="View user profile.">Vladimir Slepnev</a> at Tue, 09/27/2005 - 19:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-10269"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10269" class="active">No GC ;&gt;</a></h3>
 <div class="content"><blockquote ><p >For example: you alluded to my mock Java sample as "stupid", but... dont' you think that, if you're embedding a functional language within C++, you're going to need a garbage collector at some point? Yes, value types help, but they don't solve all problems. OCaml has a GC. Haskell has a GC. And even Java has a GC... so my example wasn't so stupid after all :-)</p></blockquote>
<p >Well, the most important value type in C++ is the smart pointer. ;&gt;  Not only can you use vanilla strategies like reference counting, you can use a good smart pointer framework to implement a garbage-collected pointer.  Of course, if you absolutely must have a "pure" garbage collector, you can just link one in to the C++ program as well.  Not only does C++ come with the kitchen sink, it comes with an optional garbage disposal too! ;&gt;</p></div>
 <div class="links">By <a href="user/2166" title="View user profile.">David B. Held</a> at Wed, 09/28/2005 - 17:17 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-10143"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10143" class="active">Just for the fun of it...</a></h3>
 <div class="content"><p ><a href="http://lua-users.org/wiki/HammingNumbers">Here it is in Lua</a>, with a fairly complete lazy infinite sequence implementation using promises: </p></div>
 <div class="links">By <a href="user/2211" title="View user profile.">rici</a> at Tue, 09/27/2005 - 02:38 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-10149"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10149" class="active">Python version</a></h3>
 <div class="content"><p >Okay, that is a challenge. :)</p>
<pre >
def scale(n, it):
    for e in it: yield n * e

def cons(x, it):
    yield x
    for e in it: yield e

def merge(xs, ys):
    x, y = xs.next(), ys.next()
    if x == y:
        for e in cons(x, merge(xs, ys)): yield e
    elif x <p >
This basically follows the Haskell version point for point except that it's done using generators and iterator algebra (by the way, the above merge function only works with infinite iterators since it doesn't catch StopIteration).</p></div>
 <div class="links">By <a href="user/1250" title="View user profile.">Per Vognsen</a> at Tue, 09/27/2005 - 13:22 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-10155"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10155" class="active">That&#039;s very pretty, but...</a></h3>
 <div class="content"><br >
<pre >
&gt;&gt;&gt; from itertools import izip
&gt;&gt;&gt; for i, e in izip(range(100000), seq()):
...   if i % 10000 == 0:
...     print i, e
... 
0 1
Traceback (most recent call last):
  File "", line 1, in ?
  File "", line 3, in seq
<span >&lt;snip /&gt;</span>
  File "", line 3, in cons
  File "", line 2, in merge
RuntimeError: maximum recursion depth exceeded
</pre><p >
To be fair to Python, a nice fast working solution is in <a href="http://mail.python.org/pipermail/python-list/2005-January/262268.html">here</a>, from a thread previously referenced in this topic.</p></div>
 <div class="links">By <a href="user/2211" title="View user profile.">rici</a> at Tue, 09/27/2005 - 14:55 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-10157"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10157" class="active">Well...</a></h3>
 <div class="content"><p >The Haskell version has the same number of recursions as my Python version, up to a constant factor. None of the recursions in either version are in tail call position, so they cannot be optimized away. So as far as expressivity at the language level is concerned, I don't think the maximum recursion depth bail-out is very relevant--if you tested it on Stackless (or any other Python implementation with a priori unbounded call stack) there would be no issue aside from performance (a function call in Python is at least two heap allocations).</p>
<p >By the way, I wasn't trying to present my code as "the best" or whatever, I just wrote it up to see how close to the spirit of the Haskell code I could get without doing any insane stunts. I figured I might as well share it.</p></div>
 <div class="links">By <a href="user/1250" title="View user profile.">Per Vognsen</a> at Tue, 09/27/2005 - 15:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-10161"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10161" class="active">Sharing vs. reevaluation</a></h3>
 <div class="content"><blockquote ><p >
The Haskell version has the same number of recursions as my Python version, up to a constant factor.
</p></blockquote>
<p >I'm just a casual Python user, but it seems to me that your version starts new generators for each recursive call to <code >seq()</code>, whereas the Haskell version shares the <code >ham</code> list.</p>
<blockquote ><p >
None of the recursions in either version are in tail call position [..]
</p></blockquote>
<p >But the recursive calls of <code >ham</code> are on lazy  positions and the Haskell program only needs constant stack space.</p></div>
 <div class="links">By <a href="user/1238" title="View user profile.">Ronny Wichers Schreur</a> at Tue, 09/27/2005 - 16:55 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-10162"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-10162" class="active">Yes</a></h3>
 <div class="content"><p >You're absolutely right, that's what I get for only being a casual Haskell user (if even that). Oh well.</p></div>
 <div class="links">By <a href="user/1250" title="View user profile.">Per Vognsen</a> at Tue, 09/27/2005 - 16:59 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-20994"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-20994" class="active">Haskell-to-Scala translation</a></h3>
 <div class="content"><p >Just for kicks, here's a <a href="http://scala.epfl.ch/">Scala</a> solution:</p>


<pre >object hamming extends Application {
  import java.math.BigInteger

  def merge(xs: Stream[BigInteger], ys: Stream[BigInteger]): Stream[BigInteger] =
    if (xs.isEmpty) ys
    else if (ys.isEmpty) xs
    else {
      val x = xs.head
      val y = ys.head
      val cmp = x compareTo y

      if (cmp == 0) Stream.cons(x, merge(xs.tail, ys.tail))
      else if (cmp &lt; 0) Stream.cons(x, merge(xs.tail, ys))
      else Stream.cons(y, merge(xs, ys.tail))
    }

  def seq: Stream[BigInteger] =
    Stream.cons(BigInteger.ONE,
                merge(seq map new BigInteger("2").multiply,
                      merge(seq map new BigInteger("3").multiply,
                            seq map new BigInteger("5").multiply)))

                            

  Console.println("The first 20 numbers:")
  Console.println (seq.take(20).mkString("", ", ", ""))

  Console.print("\nThe 100th number (counting from 0): ")
  Console.println(seq.drop(100).head)

  Console.println("\nThe 1000th:")
  Console.println(seq.drop(1000).head)
}</pre>

<p >It's a real shame it doesn't work.  You can compute the first 100 numbers, but you can't compute
1000.
</p>

<pre ><strong >$ scalac hamming.scala</strong>
<strong >$ ls -lh</strong>
total 80K
-rw-rw-r-- 1 vadim vadim 1.1K Sep  7 19:59 hamming$$anonfun$0.class
-rw-rw-r-- 1 vadim vadim 1.1K Sep  7 19:59 hamming$$anonfun$1.class
-rw-rw-r-- 1 vadim vadim 1.1K Sep  7 19:59 hamming$$anonfun$2.class
-rw-rw-r-- 1 vadim vadim 1.5K Sep  7 19:59 hamming$$anonfun$3$$anonfun$4.class
-rw-rw-r-- 1 vadim vadim 1.5K Sep  7 19:59 hamming$$anonfun$3$$anonfun$5.class
-rw-rw-r-- 1 vadim vadim 1.5K Sep  7 19:59 hamming$$anonfun$3$$anonfun$6.class
-rw-rw-r-- 1 vadim vadim 1.3K Sep  7 19:59 hamming$$anonfun$3.class
-rw-rw-r-- 1 vadim vadim  868 Sep  7 19:59 hamming.class
-rw-rw-r-- 1 vadim vadim 2.4K Sep  7 19:59 hamming$.class
-rw-rw-r-- 1 vadim vadim  992 Sep  7 17:55 hamming.scala
<strong >$ time scala hamming</strong>
The first 20 numbers:
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36

The 100th number (counting from 0): 1600

The 1000th:
<span >java.lang.OutOfMemoryError: Java heap space</span>

real	0m11.424s
user	0m9.053s
sys	0m0.344s</pre></div>
 <div class="links">By <a href="user/1114" title="View user profile.">el-vadimo</a> at Fri, 09/08/2006 - 00:08 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-20999"></a>
<div class="comment">
 <h3 class="title"><a href="node/608#comment-20999" class="active">Relying on libraries</a></h3>
 <div class="content"><p >This is common language bigotry, and the authors cheat on their C++ "solution".  They're relying on a heavyweight library class to do the difficult work, and thus hiding both the complexity and performance implications of their solution.</p>
<p >If you're going to compare language expressiveness and programming paradigms using examples like the Hamming problem, YOU HAVE TO ACTUALLY SOLVE THE PROBLEM, and not call some big library function to solve it for you.  Otherwise you're just comparing libraries, and degenerately, an arbitrarily crappy language with a library that includes GiveMeHammingNumbers() wins.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Fri, 09/08/2006 - 17:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div></form>
<!-- end content -->
 <div id="footer"><hr style="border-width: 0pt 0pt 1px;" />
Logs:
          <a href="http://wmf.editthispage.com/">Hack The Planet</a>
          ; <a href="http://www.javalobby.org">JavaLobby</a>
          ; <a href="http://www.pythonware.com/daily">Daily Python-URL</a>
 ; <a href="http://thedailywtf.com/default.aspx">Daily WTF</a>
 ; <a href="http://phplens.com/phpeverywhere/">PHP everywhere</a> ; <a href="/node/view/13">(more)</a><br>
Wikis:
         <a href="http://c2.com/cgi/wiki?RecentChanges">WikiWiki</a>
         ; <a href="http://erlang.sics.se/wiki.html">Erlang</a>
; <a href="http://ww.telent.net/cliki/Recent%20Changes">Common Lisp</a>


         ; <a href="http://www.haskell.org/hawiki/RecentChanges">Haskell</a>
         ; <a href="http://minnow.cc.gatech.edu/squeak/recent">Squeak</a>
         ; <a href="http://purl.org/thecliff/tcl/wiki">Tcl</a> ; <a href="http://www.program-transformation.org/Transform/WebChanges">Program Transformation</a>
<img src="http://sac.appsolutions.com/hitme?id=ltu&a=hit">
</div>
   </td>
   <td id="sidebar-right"><div class="block block-archive" id="block-archive-0">
 <h2 class="title">Browse archives</h2>
 <div class="content">
<!-- calendar -->
<div class="calendar"><table summary="A calendar to browse the archives.">
 <caption><a href="archive/2006/08/09" title="Previous month">«</a> September 2006  </caption>
 <tr class="header-week">
 <th abbr="Sunday">Su</th>
 <th abbr="Monday">Mo</th>
 <th abbr="Tuesday">Tu</th>
 <th abbr="Wednesday">We</th>
 <th abbr="Thursday">Th</th>
 <th abbr="Friday">Fr</th>
 <th abbr="Saturday">Sa</th>
</tr>
 <tr class="row-week"><td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
  <td class="day-link"><a href="archive/2006/9/1" title="1 post">1</a></td>
  <td class="day-link"><a href="archive/2006/9/2" title="2 posts">2</a></td>
 </tr>
 <tr class="row-week">
  <td class="day-link"><a href="archive/2006/9/3" title="2 posts">3</a></td>
  <td class="day-normal">4</td>
  <td class="day-normal">5</td>
  <td class="day-normal">6</td>
  <td class="day-normal">7</td>
  <td class="day-link"><a href="archive/2006/9/8" title="1 post">8</a></td>
  <td class="day-today"><a href="archive/2006/9/9" title="4 posts">9</a></td>
 </tr>
 <tr class="row-week">
  <td class="day-future">10</td>
  <td class="day-future">11</td>
  <td class="day-future">12</td>
  <td class="day-future">13</td>
  <td class="day-future">14</td>
  <td class="day-future">15</td>
  <td class="day-future">16</td>
 </tr>
 <tr class="row-week">
  <td class="day-future">17</td>
  <td class="day-future">18</td>
  <td class="day-future">19</td>
  <td class="day-future">20</td>
  <td class="day-future">21</td>
  <td class="day-future">22</td>
  <td class="day-future">23</td>
 </tr>
 <tr class="row-week">
  <td class="day-future">24</td>
  <td class="day-future">25</td>
  <td class="day-future">26</td>
  <td class="day-future">27</td>
  <td class="day-future">28</td>
  <td class="day-future">29</td>
  <td class="day-future">30</td>
 </tr>
</table></div>

</div>
</div>
<div class="block block-forum" id="block-forum-0">
 <h2 class="title">Active forum topics</h2>
 <div class="content"><div class="item-list"><ul><li><a href="node/1684" title="153 comments">Closures for Java or money back</a></li><li><a href="node/608" title="213 comments" class="active">expressivity of &quot;idiomatic C++&quot;</a></li><li><a href="node/1716" title="1 comment">linux vs windows which is more compatible</a></li><li><a href="node/1715">Rewriting Haskell Strings</a></li><li><a href="node/1713">OOPSLA 2006 Call for Participation</a></li></ul></div><div class="more-link"><a href="forum" title="Read the latest forum topics.">more</a></div></div>
</div>
<div class="block block-forum" id="block-forum-1">
 <h2 class="title">New forum topics</h2>
 <div class="content"><div class="item-list"><ul><li><a href="node/1716" title="1 comment">linux vs windows which is more compatible</a></li><li><a href="node/1715">Rewriting Haskell Strings</a></li><li><a href="node/1713">OOPSLA 2006 Call for Participation</a></li><li><a href="node/1712" title="9 comments">Small Value Set Types</a></li><li><a href="node/1710">FringeDC- New Washington DC Organization for Fringe Programming Languages</a></li></ul></div><div class="more-link"><a href="forum" title="Read the latest forum topics.">more</a></div></div>
</div>
</td>
  </tr>
 </table>
 </body>
</html>
