<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus) | Lambda the Ultimate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<base href="http://lambda-the-ultimate.org/" />
<style type="text/css" media="all">@import "misc/drupal.css";</style> <link rel="SHORTCUT ICON" href="favicon.ico"> <link rel="stylesheet" type="text/css" href="themes/chameleon/common.css" />
<style type="text/css" media="all">@import "themes/chameleon/ltu/style.css";</style></head><body>
 <div id="header">  <h1 class="site-name title"><a href="">Lambda the Ultimate</a></h1>  <img src="themes/chameleon/ltu/tagline.png" alt="The Programming Languages Weblog" /><div id="search-form" style="text-align:right;"><form action="search" method="post">  <input class="form-text" type="text" size="15" value="" name="edit[keys]" id="edit-keys" />&nbsp;  <input class="form-submit" type="submit" value="Search" />&nbsp;</form></div>
</div>
 <table id="content">
  <tr>
   <td id="sidebar-left"><div class="block block-block" id="block-block-1">
 <h2 class="title"></h2>
 <div class="content"><b>
<div style="text-align:right">
<p>
<a href="/rss.xml"><img src="/misc/xml.gif" border=0 /></a><p>
<a href="/">Home</a><p>
<a href="/node/view/34">Feedback</a><p>
<a href="/node/view/40">FAQ</a><p>
<a href="node/view/492">Getting Started</a><p>
<a href="/forum/1">Discussions</a><p>
<a href="/forum/2">Site operation discussions</a><p>
<a href="/tracker">Recent Posts</a><p>
<a href="/node/add/forum/1">(new topic)</a><p>
<a href="/node/view/49">Departments</a><p>
<a href="/node/view/2">Courses</a><p>
<a href="/node/view/4">Research Papers</a><p>
<a href="/node/view/3">Design Docs</a><p>
<a href="/node/view/5">Quotations</a><p>
<a href="/node/view/7">Genealogical Diagrams</a><p>
<a href="/classic/lambda-archive1.html">Archives</a>
</div>
</b>
<hr style="border-width:0 0 1px 0" />
</div>
</div>
<div class="block block-user" id="block-user-0">
 <h2 class="title">User login</h2>
 <div class="content"><form action="user/login?destination=node%2F2340" method="post">
<div class="user-login-block">
<div class="form-item">
 <label for="edit-name">Username:</label><br />
 <input type="text" maxlength="64" class="form-text" name="edit[name]" id="edit-name" size="15" value="" />
</div>
<div class="form-item">
 <label for="edit-pass">Password:</label><br />
 <input type="password" class="form-password" maxlength="64" name="edit[pass]" id="edit-pass" size="15" value="" />
</div>
<input type="submit" class="form-submit" name="op" value="Log in"  />
</div>

</form>
<div class="item-list"><ul><li><a href="user/register" title="Create a new user account.">Create new account</a></li><li><a href="user/password" title="Request new password via e-mail.">Request new password</a></li></ul></div></div>
</div>
<div class="block block-user" id="block-user-1">
 <h2 class="title">Navigation</h2>
 <div class="content"><div class="menu">
<ul>
<li class="leaf"><a href="tracker">recent posts</a></li>

</ul>
</div></div>
</div>
</td>
   <td id="main">
<div class="breadcrumb"><a href="">Home</a> &raquo; <a href="forum">forums</a> &raquo; <a href="forum/1">LtU Forum</a></div><h2>Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus)</h2>
<!-- begin content -->
<div class="node">
 <div class="content">
<p ><a href="http://www.informatik.uni-bonn.de/~loeh/LambdaPi.html">Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus)</a><br >
    Andres Löh, Conor McBride and Wouter Swierstra </p>
<blockquote ><p >
    We present an implementation in Haskell of a dependently-typed lambda calculus that can be used as the core of a programming language. We show that a dependently-typed lambda calculus is no more difficult to implement than other typed lambda calculi. In fact, our implementation is almost as easy as an implementation of the simply typed lambda calculus, which we emphasize by discussing the modifications necessary to go from one to the other. We explain how to add data types and write simple programs in the core language, and discuss the steps necessary to build a full-fledged programming language on top of our simple core.
</p></blockquote> </div>
 <div class="links">By <a href="user/1296" title="View user profile.">Greg Buchholz</a> at 2007-07-09 16:19 | <a href="taxonomy/term/1">LtU Forum</a> | <a href="node/2351" title="iTasks: Defining Interactive Work Flows for the Web">previous forum topic</a> | <a href="node/2348" title="ErlCaml">next forum topic</a> | <a href="http://www.technorati.com/search/lambda-the-ultimate.org/node/2340" title="Technorati search of other blogs commenting on this post.">other blogs</a> | 3368 reads</div>
</div>
<a id="comment"></a>
<form method="post" action="comment"><div>
<h2 class="title">Comment viewing options</h2><div><div class="form-item">
 <select name="mode"> <option value="1">Flat list - collapsed</option>
 <option value="2">Flat list - expanded</option>
 <option value="3">Threaded list - collapsed</option>
 <option value="4" selected="selected">Threaded list - expanded</option>
</select>
<select name="order"> <option value="1">Date - newest first</option>
 <option value="2" selected="selected">Date - oldest first</option>
</select>
<select name="comments_per_page"> <option value="10">10 comments per page</option> <option value="30">30 comments per page</option> <option value="50">50 comments per page</option> <option value="70">70 comments per page</option> <option value="90">90 comments per page</option> <option value="150">150 comments per page</option> <option value="200" selected="selected">200 comments per page</option></select>
<input type="hidden" name="threshold" value="0" />
 <input type="submit" class="form-submit" name="op" value="Save settings"  />

 <div class="description">Select your preferred way to display the comments and click "Save settings" to activate your changes.</div>
</div>
</div><input type="hidden" name="edit[nid]" value="2340" />
</div></form><form method="post" action="comment"><div>
<input type="hidden" name="edit[nid]" value="2340" />
<a id="comment-34896"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34896" class="active">Time to become a</a></h3>
 <div class="content"><p >Time to become a contributing editor, don't you think?</p></div>
 <div class="links">By <a href="user/1" title="View user profile.">Ehud Lamm</a> at Mon, 2007-07-09 16:33 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-34898"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34898" class="active">Haskell&#039;s hodgepodge</a></h3>
 <div class="content"><p >I love papers that come with source code for interpreters, especially when it helps in exploring the theory.</p>
<p >The beginning of the introduction provides an interesting perspective on this paper:</p>
<blockquote ><p >
Most Haskell programmers are hesitant to program with dependent types.  It is said that type checking becomes undecidable; the phase distinction between type checking and evaluation is lost; the type checker will always loop; and that dependent types are really, really hard.
</p><p >
The same Haskell programmers, however, are perfectly happy to program with a ghastly hodgepodge of generalized algebraic data types, multi-parameter type classes with functional dependencies, impredicative higher-ranked types, and even data kinds.  They will go to great lengths to avoid dependent types.
</p><p >
This paper aims to dispel many misconceptions Haskell programmers may have about dependent types. We will present and explain a dependently-typed lambda calculus &lambda;<sub >&Pi;</sub> that can serve as the core of a dependently-typed programming language, much like Haskell can be based on the polymorphic lambda calculus <i >F</i><sub >&omega;</sub>.
</p></blockquote></div>
 <div class="links">By <a href="user/2" title="View user profile.">Anton van Straaten</a> at Mon, 2007-07-09 16:36 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-34902"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34902" class="active">Dependent types</a></h3>
 <div class="content"><p >The authors are certainly correct that dependent types provide a cleaner solution than the hodge-podge of features found in more widely-used languages.</p>
<p >I'm afraid they are also correct in the suggestion at the end of the paper that regaining the expressiveness needed for large-scale programming may require the introduction of general recursion, and the possibility that the typechecker will loop in some circumstances.</p>
<p >Ultimately, we need to embrace partiality in the general case of typechecking.  Large-scale programming will never be done in a total language, because the burden of proving your program total imposes a development cost multiplier of several orders of magnitude.  And, when you mix types and values to gain expressiveness, any partiality in the value language necessary percolates up to the type system.</p>
<p >So, we need to grow comfortable with partial type systems.  I feel the lack of significant progress in type theory in the past decade is largely a result of refusing to embrace general type recursion, which causes researchers to focus in on microscopic details of proving totality for slight improvements on existing type systems, rather than exploring the wider possibilities.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Mon, 2007-07-09 19:18 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34907"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34907" class="active">Can of non-terminating worms</a></h3>
 <div class="content"><p ><i >So, we need to grow comfortable with partial type systems. I feel the lack of significant progress in type theory in the past decade is largely a result of refusing to embrace general type recursion, which causes researchers to focus in on microscopic details of proving totality for slight improvements on existing type systems, rather than exploring the wider possibilities.</i></p>
<p >I understand where you're coming from Tim, but do you really want to introduce another source of non-termination into the development process?  Can you imagine your typical programming team mucking about with a type-checker debugger, trying to figure out why their app won't compile?   </p>
<p >Even for those of us with a lot of type theory under our belts would probably find that a wee bit painful.</p>
<p >It would be nice if type-checking could be counted on to solve a whole range of problems without invoking the halting problem, but I think realistically the best we can do is to chip away at the edges that can be shown to terminate.</p>
<p >Maybe while we're chipping away, someone will make a big breakthrough, and we'll get our wish, but the low-hanging fruit seems to have been already picked.</p>
<p >Are there specific features that, having thought it through, you think would be "safe" to use in normal development circumstances without undue risk?</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Mon, 2007-07-09 20:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34913"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34913" class="active">Non-terminating compilers are not new...</a></h3>
 <div class="content"><p >There are lots of languages and compilers which do not terminate on all programs (or take so long they might as well not terminate):</p>
<p >Common Lisp and Scheme compilers can fail to terminate if the user writes a non-terminating macro.</p>
<p >GHC (the Glasgow Haskell Compiler) implements type-system extensions which, if enabled, can make the compiler fail to terminate on some programs.</p>
<p >C++ compilers can be forced to take an arbitrarily long amount of time doing template expansion.</p>
<p >Hindley-Milner type inference can take exponential time in the length of the program text, so ML and Haskell compilers can be made arbitrarily slow.</p>
<p >Somehow people muddle along with all of these systems.  One key is that in all of these cases, it's difficult for a less-skilled programmer to write "bad" programs (that make the compiler take effectively forever) by accident; they use features (write your own macros, create your own templates, use fancy type-system extensions) that are usually avoided for simple programs, and are used much more often in libraries than in callers of libraries.  (Hindley-Milner typechecking seems not to be a problem in practice in any case.)</p>
<p >I hope (and expect) that there are interesting uses of Turing-complete type systems that would have the same properties: most people would never run into the non-terminating cases, and the people who do would know what they are doing.</p>
<p >Also, note that if you have a powerful type-level language (like Coq), carefully restricting it to be Turing-incomplete and terminating doesn't help much: the compiler might terminate in theory, but if you can make the compiler compute factorial(factorial(1000)) in unary, it's not going to terminate in practice.</p></div>
 <div class="links">By <a href="user/866" title="View user profile.">Carl Witty</a> at Mon, 2007-07-09 21:24 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-34915"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34915" class="active">We lived in a lake...</a></h3>
 <div class="content"><p ><i >There are lots of languages and compilers which do not terminate on all programs (or take so long they might as well not terminate)</i></p>
<p >Many of your examples have one thing in common: though there are people who muddle along with them, they are normally considered "harder" to develop with "in the field", or set aside for "advanced use".</p>
<p >In particular, macros, templates, and GHC type extensions are optional extensions of the language: you don't have to use them, and you do so "at your own risk".</p>
<p >A dependent type system in order to be meaningful and useful is going to be mandatory: you won't be able to avoid it if you want to write in the language in question.</p>
<p >And as Tim himself notes, as you add refinements to your types the dependent types you create are going to get more complex and harder to reason about, even if you don't mean them to.</p>
<p >I really do think we are talking about a different order of risk on top of the one that things such as macros and templates already bring to the table.</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Mon, 2007-07-09 21:58 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-34919"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34919" class="active">I do not think this is true</a></h3>
 <div class="content"><p >I don't think it's necessarily the case that adding refinements will add that much extra complexity. If you do it GADT style, it will be unpleasant, but you don't have to do that. You can potentially write things like:</p>
<pre >
when :: Bool -&gt; Type
when b = if b then Unit else Void

foo : n:Nat -&gt; (when (prime n)) -&gt; (when (n &gt; 50)) -&gt; result
...
</pre><p >
and then treat each constraint independently. </p></div>
 <div class="links">By <a href="user/1111" title="View user profile.">neelk</a> at Mon, 2007-07-09 22:20 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-34921"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34921" class="active">dependent type system mandatory?</a></h3>
 <div class="content"><p ><i >A dependent type system in order to be meaningful and useful is going to be mandatory: you won't be able to avoid it if you want to write in the language in question.</i></p>
<p >I'm not sure what you mean here.  In a sense, it's trivially true; if you write a program in a language with a dependent type system, you have to use that type system, just like if you write a program in ML you have to use Hindley-Milner.</p>
<p >But I don't agree that it has to pervade your programming experience.  In fact, I would think the opposite would be true: for a language with a dependent type system to be useful, you have to be able to spend a lot of your programming time not thinking about types at all.  (I think the same is true of languages without dependent type systems, as well.  After all, unless you're writing a very strange program -- like the Coq proof of the four-color theorem -- the meat of any program is at the value level.)</p>
<p >And in fact I find that when I write Haskell code, I don't spend a lot of time thinking about types; the compiler handles that for me.  I don't see why a dependent type system would have to be more intrusive than the Haskell type system for normal programming.</p></div>
 <div class="links">By <a href="user/866" title="View user profile.">Carl Witty</a> at Mon, 2007-07-09 22:42 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:125px;">
<a id="comment-34924"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34924" class="active">The types depend on values</a></h3>
 <div class="content"><p ><i >the meat of any program is at the value level</i></p>
<p >This is the problem: with dependent types you are mixing your values into the type system; you can't reason about the types as a system wholly independently from the possible values that can be embedded in it, or for that matter the values wholly independently from the types.</p>
<p >This is partly what makes dependent types so powerful, but I think also problematic from both a practical and theoretical point of view.</p>
<p >And why I don't think Tim is going to get his wish (even though I wish it along with him).</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Tue, 2007-07-10 00:06 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-34933"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34933" class="active">I think the usefulness of</a></h3>
 <div class="content"><p >I think the usefulness of dependent type systems far outweights its potential problems. Dependent type systems allow for far better optimizations of code and allow for far better error catching at compile-time than non-dependent type systems. Sometimes the compiler may not terminate during processing of a dependent type system, but that is not really very important: it is the programmer that has introduced the recursion, so the programmer is responsible about it. As others have pointed, the C++ template meta-programming system 'suffers' from this, but it opens the door for many interesting capabilities.</p></div>
 <div class="links">By <a href="user/1623" title="View user profile.">Achilleas Margaritis</a> at Tue, 2007-07-10 10:31 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:150px;">
<a id="comment-34962"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34962" class="active">Reasoning about types...</a></h3>
 <div class="content"><p ><i >you can't reason about the types as a system wholly independently from the possible values that can be embedded in it</i></p>
<p >But most of the time, I don't reason about the types at all...that's the compiler's job.  I only reason about types and the type system in two cases: 1) I'm trying to come up with a new use of the type system which is sufficiently different than anything I've done before, or 2) the compiler spits out a type error where it is not immediately obvious what the problem is.  Both of these are somewhat rare events; certainly they add up to a tiny fraction of my total Haskell programming time.  I don't see why this would be different in a language with dependent types.</p></div>
 <div class="links">By <a href="user/866" title="View user profile.">Carl Witty</a> at Tue, 2007-07-10 19:01 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:175px;">
<a id="comment-34973"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34973" class="active">It seems easy...</a></h3>
 <div class="content"><p ><i > I don't see why this would be different in a language with dependent types.</i></p>
<p >I'm afraid this seems like a speculation by analogy on strongly normalizing HM type checking.  The whole idea that Tim was proposing was doing away with the strongly normalizing guarantee.</p>
<p >If you take away this guarantee (and make use of the power it offers) you will certainly have to reason about typing termination (and hence the type system) the same way you have to reason about program termination.</p>
<p >You may want to read Conor McBride's papers on the issue if you don't find my arguments convincing.</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Tue, 2007-07-10 21:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-35010"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35010" class="active">In defense of Hindley-Milner...</a></h3>
 <div class="content"><p >Exponential behavior only arises from deeply nested polymorphic let expressions,  i.e.</p>
<pre >
let x = let y = 3
            z = let foo n = n + 1
                 in foo y
         in y + z 
 in x * x
</pre><p >Expert or not,  nobody writes code like that.  Thus Hindley-Milner is efficient in practice,  as you mentioned. (I seem to remember the term "quasi-linear" from somewhere...)</p></div>
 <div class="links">By <a href="user/1602" title="View user profile.">Leon P Smith</a> at Wed, 2007-07-11 19:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-35015"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35015" class="active">Exponential behaviour</a></h3>
 <div class="content"><p >In fact, HM type inference is only exponential when the types get exponentially large. So this occurs only for programs you couldn't practically write without type inference in the first place.</p>
<p >(That is, your example does not exhibit exponential behaviour yet.)</p></div>
 <div class="links">By <a href="user/1569" title="View user profile.">Andreas Rossberg</a> at Thu, 2007-07-12 08:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34911"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34911" class="active">C++</a></h3>
 <div class="content"><p >C++ already has this problem, so I'd guess quite a lot of programmers are comfortable with the idea (or oblivious to the problems).</p></div>
 <div class="links">By <a href="user/2015" title="View user profile.">fanf</a> at Mon, 2007-07-09 21:17 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34977"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34977" class="active">Nontermination and Soundness</a></h3>
 <div class="content"><p >You probably already know this, but type-erasure for a dependently-typed language is unsound in a partial language. The best you can do is to actually evaluate all the types and witness terms in a program, to make sure a "proof" isn't somebody lying with nontermination. It's like dynamic typing, except that the runtime "tag" checking fails only by looping! That's the situation with passing GADTs as evidence in Haskell - evaluating them is required for type-safety. <a href="http://www.haskell.org/pipermail/haskell-cafe/2006-September/018248.html">Conor McBride explains</a>. The Epigram paper <a href="http://www.e-pig.org/downloads/indfam.pdf">Inductive families need not store their indices</a> shows how much you can erase in a strongly-normalizing language.</p>
<p >I was talking about partial and total languages above, but what really matters is whether an individual term is strongly normalizing. You can use general recursion in your calculations and still only use total expression in types if your type system separates them. Thorsten Altenkirch and others are working on a monad for partiality, with that in mind (<A href="http://www.cs.nott.ac.uk/~txa/talks/bctcs06.pdf">slides</a>).</p>
<p >This fits with the pay-as-you-go typing Epigram is aiming for - you can define simple algebraic data types in a dependently typed language and it should be no more trouble then using ML, or you can define better specified types, justify functions a bit more, and get stronger guarantees. Similarly, you should be able to code with general recursion if you want to, and suffer the costs if you use that code in types, or maybe work a little more to show something total, for easier reasoning about it. I'd like to think the bits past 11 on Paul Snively's dynamic typing  static typing slider are falling into place.</p></div>
 <div class="links">By <a href="user/2755" title="View user profile.">Brandon Moore</a> at Tue, 2007-07-10 22:42 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-35030"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35030" class="active">Type erasure requires totality</a></h3>
 <div class="content"><p >You've made a very important point here: type erasure requires totality.  Any dependent-typed expression that may diverge must be fully evaluted at runtime, otherwise the type system is unsound.</p>
<p >If the language is ambivalent about partiality, this means dependent types carry a significant runtime cost.</p>
<p >The answer is that dependent-typed, performance-critical languages need to have some sort of effects-typing system so that the runtime can erase types whose computation is conservatively known to be total.  In the general case, it won't be able to ascertain that, but in the typical cases of simple dependent types (e.g. the Haskell-like subset), it's pretty straightforward.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Thu, 2007-07-12 19:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-35049"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35049" class="active">Proof-Carrying Code</a></h3>
 <div class="content"><p >Tim, how does this square with a desire to implement proof-carrying code in order to provide security guarantees with respect to code, either dynamically loaded or received over the network, from untrusted sources?</p></div>
 <div class="links">By <a href="user/289" title="View user profile.">Paul Snively</a> at Fri, 2007-07-13 14:47 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:100px;">
<a id="comment-35056"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35056" class="active">Proof-Carrying Code</a></h3>
 <div class="content"><p >For security, it just means that non-total type expression can't be erased, but must be evaluated at runtime to preserve the semantics.  It's a performance hit, probably not a huge one.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Fri, 2007-07-13 19:27 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-34910"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34910" class="active">Can you imagine your typical</a></h3>
 <div class="content"><blockquote ><p >Can you imagine your typical programming team mucking about with a type-checker debugger, trying to figure out why their app won't compile?</p></blockquote>
<p >Hey, C++ templates are a Turing complete compile-time construct, hence they can loop.  Industry-wide, maybe 0.01% of C++ debugging time is spent determining why a template expression loops.  Much as we all hate C++, it's the world's leading mainstream programming language today, and the partial typechecker is absolutely not a barrier to adoption.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Mon, 2007-07-09 21:17 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34914"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34914" class="active">The same can of worms?</a></h3>
 <div class="content"><p ><i >Hey, C++ templates are a Turing complete compile-time construct, hence they can loop.</i></p>
<p >They may have the power to loop, but, though I haven't used them myself in a very long time, my recollection is that one normally doesn't call upon that power very often (perhaps <i >ever</i> in a well-designed template library).  Has this changed?</p>
<p >If it hasn't, then the template language has more power than it really needs to fulfill most or all of its purpose, and could probably be replaced with a guaranteed terminating system without much loss of effectiveness.</p>
<p >What you seem to be proposing sounds quite different to me: like you want to routinely call upon that power, bringing along its full complexity by necessity.  Is this really a comparable situation to C++ templates?</p></div>
 <div class="links">By <a href="user/4" title="View user profile.">Marc Hamann</a> at Mon, 2007-07-09 21:40 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34918"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34918" class="active">modern C++ style and compile time nontermination </a></h3>
 <div class="content"><p ><i >They may have the power to loop, but, though I haven't used them myself in a very long time, my recollection is that one normally doesn't call upon that power very often (perhaps ever in a well-designed template library).</i></p>
<p ><br >In chapter 3 of <b >Modern C++ Design</b> by Alexandrescu he introduces template type lists, essentially laying the groundwork for a Lisp in C++ templates at compile time.</p>
<p ><br >"Typelists are a C++ tool for manipulating collections of types. They offer for types all the fundamental operations that lists of values support."</p></div>
 <div class="links">By <a href="user/1560" title="View user profile.">James McCartney</a> at Mon, 2007-07-09 22:12 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34920"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34920" class="active">Loops allow tree definitions</a></h3>
 <div class="content"><blockquote ><p >They may have the power to loop, but, though I haven't used them myself in a very long time, my recollection is that one normally doesn't call upon that power very often (perhaps ever in a well-designed template library). Has this changed?</p></blockquote>
<p >Self-referential templates (i.e. recursive templates which are the same thing as loops) are useful for the definition of tree structures at compile-time. One application is the definition of parsing combinator libraries (see my recent post on LtU about the <a href="http://lambda-the-ultimate.org/node/2341">YARD parsing framework</a>). </p>
<p >I'm not sure you could write something like YARD with a weaker (e.g. guaranteed terminating) template system, but I could be wrong. </p></div>
 <div class="links">By <a href="user/1261" title="View user profile.">cdiggins</a> at Mon, 2007-07-09 22:37 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34981"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34981" class="active">The power to loop</a></h3>
 <div class="content"><blockquote ><p >
They may have the power to loop, but, though I haven't used them myself in a very long time, my recollection is that one normally doesn't call upon that power very often
</p></blockquote>
<p >An example library that uses looping constructs at compile time is <a href="http://www.boost.org/libs/python/doc/">boost::python</a>. I use it every day, as do many others. It would be tricky to modify C++ to remove non-termination but still keep this power.</p></div>
 <div class="links">By <a href="user/1545" title="View user profile.">sigfpe</a> at Tue, 2007-07-10 23:54 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-34922"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34922" class="active">Strong Normalization is a bliss</a></h3>
 <div class="content"><p >Everytime I see this discussion about non-termination pop-up I wonder, what kind of functions do you have in mind that don't have a structural or well-founded recursion argument ?</p></div>
 <div class="links">By <a href="user/3124" title="View user profile.">Matthieu Sozeau</a> at Mon, 2007-07-09 22:56 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34923"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34923" class="active">General recursion</a></h3>
 <div class="content"><p >For example, consider a dependent-typed program whose compilation constructs a parser from a parser definition in a string (say, in BNF format).  Then, when you run that program, it parses another file using that parser.  Here, we're moving something that is traditionally done at runtime to compile-time, which is sensible here since constructing a parser is a purely functional operation.</p>
<p >Well, depending on what the string contains, compiling this could loop.  So, to write the dependent-typed parser generator using wellfounded constructs, you can't simply write a function from strings to parsers, you need to construct a provably wellfounded parser by hand using constructs like primitive recursion.</p>
<p >More importantly, it's far easier for real-world programmers to write any sort of code using general recursion than to restructure everything using e.g. primitive recursion or this paper's FoldNat/NatElim constructs -- perhaps an order-of-magnitude easier.  Such productivity multipliers are a big deal for large-scale programming.</p>
<p >In those cases, programmers would much prefer to write code easily using general recursion and to debug the very rare cases where compilation doesn't terminate, than to spend a much greater effort writing these algorithms using unfamiliar induction constructs.</p></div>
 <div class="links">By <a href="user/97" title="View user profile.">Tim Sweeney</a> at Mon, 2007-07-09 23:38 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34928"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34928" class="active">Practical matters</a></h3>
 <div class="content"><p >I think you should be able to write a function from strings to (terminating) parsers and have the choice of building a proof that this function terminates to be able to compute with it. You could even have the choice to run the function assuming an hypothetical order makes it well-founded. Whether it has to be in an untrusted part of your system (eg, after extraction in Coq) or not (as in a turing-complete programming language) is a design choice. I personnaly am more inclined to the former as I want to certify programs but that's my taste :) I agree that proving that the parsers you build will terminate may be a very complex task, but that's exactly why you have dependent types: to prove complex properties. </p>
<p >The question of what can be allowed automatically is an active research area, and there are promising solutions to the problem, notably sized types could help a lot. I'm still not convinced many everyday code uses complex termination arguments. I think you can give decreasing measures most of the time. Now programming with eliminators is certainly not the way to go, but pattern-matching is more or less equivalent to it and used pervasively in ML to structure recursive programs, so the solution's already there !</p></div>
 <div class="links">By <a href="user/3124" title="View user profile.">Matthieu Sozeau</a> at Tue, 2007-07-10 09:32 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:75px;">
<a id="comment-34966"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34966" class="active">complex termination arguments</a></h3>
 <div class="content"><p ><i >I'm still not convinced many everyday code uses complex termination arguments.</i></p>
<p >Code that would require complex termination arguments is probably quite rare, but it definitely exists.</p>
<p >I recently wrote a routine (for finding the real roots of a polynomial) where the termination argument uses algebra, calculus, and number theory.  (I couldn't even produce the whole termination argument without references, although I can point at the papers you would need to read.)  Also, it uses libraries written by many different people at different times in different programming languages; subtle bugs in those libraries could make the routine loop.</p>
<p >And even then, all that I can prove is that if I had a source of random numbers, the routine would terminate with probability 1.  Since I use pseudo-random numbers, there are probably inputs that the routine does not terminate on (although I'm not at all worried about it, since those inputs would be far too large to be practical anyway).</p></div>
 <div class="links">By <a href="user/866" title="View user profile.">Carl Witty</a> at Tue, 2007-07-10 19:16 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-35024"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35024" class="active">The example you give with</a></h3>
 <div class="content"><p >The example you give with parsers is actually one I'd be quite happy to take a shot at - with a reasonable understanding of the parsing process I'm fairly sure it all drops out. It would require parsing into a grammar before compiling the grammar into a parser, but I can't help thinking that this is a good thing anyway!</p>
<p >That aside, building things in terms of more specific higher-order functions is often easier than either general or structural recursion. I can't help thinking that that's the appropriate trade-off.</p></div>
 <div class="links">By <a href="user/1621" title="View user profile.">Philippa Cowderoy</a> at Thu, 2007-07-12 14:10 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-35027"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-35027" class="active">Parsing</a></h3>
 <div class="content"><p >You can't do directly with primitive eliminators, but there's a really straightforward and beautiful trick you can use to handle parser generation and many similar algorithms (such as dataflow analysis), where you need to iterate to a fixed point. The recipe is: </p>
<p >1) generate the step function by recursing over the grammar.<br >
2) Show this function is well-founded.<br >
3) This proves iteration to a fixed point terminates. </p>
<p >Here, I give an example from parsing -- figuring out whether a grammar matches the null string or not. For simplicity, I only allow a single nonterminal, so the grammar type is equivalent to the form <code >S ::= ... | ... | ... </code> with <code >S</code> as the only nonterminal. This isn't intrinsic, but it keeps the example simple. </p>
<pre >
type gramamr = 
  | Char of char
  | Seq of grammar * grammar
  | Empty
  | False
  | Or of grammar * grammar 
  | Self

let isnull_c g b = 
  match g with
  | Empty -&gt; true
  | Char _ -&gt; false
  | Seq(g1, g2) -&gt; (isnull_c g1 b) &amp;&amp; (isnull_c g2 b)
  | False -&gt; false
  | Or(g1, g2) -&gt; (isnull_c g1 b) || (isnull_c g2 b) 
  | Self -&gt; b

(* Here, we use a non-structural recursive call, but it's justified by 
the fact that isnull_c is well-founded -- eventually you'll hit the 
base case because f can only increase v. In ML you don't track this 
fact, but you could in a dependently-typed language. *)

let rec fix f init = 
  let v = f init in
  if v = init then v else fix f v

let isnull g = fix (isnull_c g) false
</pre></p></div>
 <div class="links">By <a href="user/1111" title="View user profile.">neelk</a> at Thu, 2007-07-12 15:46 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:25px;">
<a id="comment-34944"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34944" class="active">I write lots of functions</a></h3>
 <div class="content"><p >I write lots of functions that are not structurally recursive. Of course, these functions *do* have induction metrics that go down, but I find tracking that explicitly somewhat annoying. </p>
<p >For example, here's a functional quicksort:</p>
<pre >
let rec split' x list bigger smaller = 
  match list with
  | []                   -&gt; (bigger, smaller)
  | y :: rest when x &lt; y -&gt; split' rest (y :: bigger) smaller  
  | y :: rest            -&gt; split' rest bigger (y :: smaller)

let split x list = split' x list [] []

let rec qsort list = 
  match list with 
  | []      -&gt; []
  | [x]     -&gt; [x]
  | x :: xs -&gt; let (bigger, smaller) = split x xs in
               (qsort smaller) @ [x] @ (qsort bigger)
</pre>
<p ><code >split</code> has a structural recursive definition, but <code >qsort</code> does not; it depends on the fact that the calls to <code >split</code> return two lists, each of shorter length than the argument to <code >qsort</code>.</p>
<p >EDIT: As an engineering matter, though, I think that it's smart to stick to normalizing languages. The basic reason is that there's potentially a LOT of computation that you have to do at type-checking time, and knowing your language is normalizing means that when all you care about is inhabitation (e.g., for equality proofs), you don't have to normalize a proof term at all. That's potentially really significant for efficiency.</p></div>
 <div class="links">By <a href="user/1111" title="View user profile.">neelk</a> at Tue, 2007-07-10 14:34 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<div style="margin-left:50px;">
<a id="comment-34952"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34952" class="active">Sized types to the rescue</a></h3>
 <div class="content"><p >Indeed having to encode in the type or prove separately that split "preserves" the size of the input is cumbersome, but we know how to do it automatically ! Sized types (see e.g. Andreas Abel's PhD) would allow you to specify that<br >
split : a -&gt; list^i a -&gt; list^i a -&gt; list^i a -&gt; (list^i a, list^i a)<br >
Effectively expressing with types that the recursive calls to qsort will be ok as the size of bigger and smaller will be less than or equal to the size of xs. I know of no implementation using this technology yet but it's clearly the way to go. It even works with higher-order functions, think:<br >
map : (a^i -&gt; b) -&gt; list a^i -&gt; list b</p></div>
 <div class="links">By <a href="user/3124" title="View user profile.">Matthieu Sozeau</a> at Tue, 2007-07-10 16:09 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div>
<a id="comment-34941"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34941" class="active">Dependent Types: Easy as PIE</a></h3>
 <div class="content"><p >Given  the discussion of the usefulness and dangers of dependently typed programming, here's a draft paper by Stephanie Weirich, <a href="http://www.seas.upenn.edu/~sweirich/papers/tfp07.pdf">Dependent Types: Easy as PIE</a></p>
<blockquote ><p >Dependent type systems allow for a rich set of program properties to be expressed and mechanically verified via type checking. However, despite their significant expressive power, dependent types have not yet advanced into mainstream programming languages. We believe the reason behind this omission is the large design space for dependently typed functional programming languages, and the consequent lack of experience in dependently-typed programming and language implementations. In this newly-started project, we lay out the design considerations for a general-purpose, effectful, functional, dependently-typed language, called PIE. The goal of this project is to promote dependently-typed programming to a mainstream practice.</p></blockquote></div>
 <div class="links">By <a href="user/2352" title="View user profile.">naasking</a> at Tue, 2007-07-10 13:43 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
<a id="comment-34978"></a>
<div class="comment">
 <h3 class="title"><a href="node/2340#comment-34978" class="active">compile time loops</a></h3>
 <div class="content"><p >I wonder: suppose you have a dependently typed program that loops when you try to compile it. Now you rewrite it in a non-dependently typed programming language. Would that not necessarily mean that that program would loop at run-time?</p>
<p >If that is the case, then I say the choice is easy. The run-time loop could remain undetected until a customer runs into it.</p></div>
 <div class="links">By <a href="user/175" title="View user profile.">Sjoerd Visscher</a> at Tue, 2007-07-10 22:55 | <a href="user/login">login</a> or <a href="user/register">register</a> to post comments</div>
</div>
</div></form>
<!-- end content -->
 <div id="footer"><hr style="border-width: 0pt 0pt 1px;" />
Logs:
          <a href="http://wmf.editthispage.com/">Hack The Planet</a>
          ; <a href="http://www.javalobby.org">JavaLobby</a>
          ; <a href="http://www.pythonware.com/daily">Daily Python-URL</a>
 ; <a href="http://thedailywtf.com/default.aspx">Daily WTF</a>
 ; <a href="http://phplens.com/phpeverywhere/">PHP everywhere</a> ; <a href="/node/view/13">(more)</a><br>
Wikis:
         <a href="http://c2.com/cgi/wiki?RecentChanges">WikiWiki</a>
         ; <a href="http://erlang.sics.se/wiki.html">Erlang</a>
; <a href="http://ww.telent.net/cliki/Recent%20Changes">Common Lisp</a>


         ; <a href="http://www.haskell.org/haskellwiki/Special:Recentchanges">Haskell</a>
         ; <a href="http://minnow.cc.gatech.edu/squeak/recent">Squeak</a>
         ; <a href="http://purl.org/thecliff/tcl/wiki">Tcl</a> ; <a href="http://www.program-transformation.org/Transform/WebChanges">Program Transformation</a>
<img src="http://sac.appsolutions.com/hitme?id=ltu&a=hit">
</div>
   </td>
   <td id="sidebar-right"><div class="block block-archive" id="block-archive-0">
 <h2 class="title">Browse archives</h2>
 <div class="content">
<!-- calendar -->
<div class="calendar"><table summary="A calendar to browse the archives.">
 <caption><a href="archive/2007/07/05" title="Previous month">«</a> August 2007  </caption>
 <tr class="header-week">
 <th abbr="Sunday">Su</th>
 <th abbr="Monday">Mo</th>
 <th abbr="Tuesday">Tu</th>
 <th abbr="Wednesday">We</th>
 <th abbr="Thursday">Th</th>
 <th abbr="Friday">Fr</th>
 <th abbr="Saturday">Sa</th>
</tr>
 <tr class="row-week"><td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
<td class="day-blank">&nbsp;</td>
  <td class="day-link"><a href="archive/2007/8/1" title="2 posts">1</a></td>
  <td class="day-link"><a href="archive/2007/8/2" title="1 post">2</a></td>
  <td class="day-link"><a href="archive/2007/8/3" title="2 posts">3</a></td>
  <td class="day-normal">4</td>
 </tr>
 <tr class="row-week">
  <td class="day-today">5</td>
  <td class="day-future">6</td>
  <td class="day-future">7</td>
  <td class="day-future">8</td>
  <td class="day-future">9</td>
  <td class="day-future">10</td>
  <td class="day-future">11</td>
 </tr>
 <tr class="row-week">
  <td class="day-future">12</td>
  <td class="day-future">13</td>
  <td class="day-future">14</td>
  <td class="day-future">15</td>
  <td class="day-future">16</td>
  <td class="day-future">17</td>
  <td class="day-future">18</td>
 </tr>
 <tr class="row-week">
  <td class="day-future">19</td>
  <td class="day-future">20</td>
  <td class="day-future">21</td>
  <td class="day-future">22</td>
  <td class="day-future">23</td>
  <td class="day-future">24</td>
  <td class="day-future">25</td>
 </tr>
 <tr class="row-week">
  <td class="day-future">26</td>
  <td class="day-future">27</td>
  <td class="day-future">28</td>
  <td class="day-future">29</td>
  <td class="day-future">30</td>
  <td class="day-future">31</td>
<td class="day-blank">&nbsp;</td>
</tr>
</table></div>

</div>
</div>
<div class="block block-forum" id="block-forum-0">
 <h2 class="title">Active forum topics</h2>
 <div class="content"><div class="item-list"><ul><li><a href="node/2377" title="4 comments">First-class Polymorphism</a></li><li><a href="node/2373" title="17 comments"> Monad Description For Imperative Programmer</a></li><li><a href="node/2375" title="14 comments">Syntactic abstraction? (newbie question)</a></li><li><a href="node/2374" title="3 comments">continuations and trampolining</a></li><li><a href="node/2279" title="11 comments">Merging Functions, Modules, Classes, the whole nine yards...</a></li></ul></div><div class="more-link"><a href="forum" title="Read the latest forum topics.">more</a></div></div>
</div>
<div class="block block-forum" id="block-forum-1">
 <h2 class="title">New forum topics</h2>
 <div class="content"><div class="item-list"><ul><li><a href="node/2377" title="4 comments">First-class Polymorphism</a></li><li><a href="node/2375" title="14 comments">Syntactic abstraction? (newbie question)</a></li><li><a href="node/2374" title="3 comments">continuations and trampolining</a></li><li><a href="node/2373" title="17 comments"> Monad Description For Imperative Programmer</a></li><li><a href="node/2371">Jedi</a></li></ul></div><div class="more-link"><a href="forum" title="Read the latest forum topics.">more</a></div></div>
</div>
</td>
  </tr>
 </table>
 </body>
</html>
