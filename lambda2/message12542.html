<html><head><title>LtU Classic Archives</title></head><body><h1 class='title'><a href='http://lambda-the-ultimate.org/'>Lambda the Ultimate</a></h1><table><tr><td><table><tr><td>
<table bgcolor="navy" cellpadding="5" cellspacing="0" border="0" width="100%"><tr>
<td>
<img src='folder2.gif' height="14" width="17" border="0" alt="inactiveTopic"> <font color="white"><b>Nullable Types</b></font><br>
<font color="white" size="-1">started 5/29/2004; 3:42:07 AM - last post 6/3/2004; 11:21:16 AM</font>
</td>
</tr></table>
</td></tr>
<tr><td>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Ehud Lamm</a> - Nullable Types <a name="12542">&nbsp;</a><a href='#12542' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/29/2004; 3:42:07 AM (reads: 12708, responses: 9)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
<a name="a12542"></a><table border="0" cellspacing="10" width="400">
	<tr>
		<td colspan="2" align="left" valign="top" width="85%" bgcolor="#E6E6E6"><b><a href='#12542'>Nullable Types</a></b></td>
		</tr>
	<tr>
		<td align="left" valign="top">
			A <a href="http://patricklogan.blogspot.com/2004/05/nullable-types.html">discussion</a> of nullable types is <a href="http://www.netcrucible.com/blog/PermaLink.aspx?guid=62a3eac4-3a1a-4429-be64-fd1232adce65">sweeping</a> through the C# <a href="http://blogs.msdn.com/ericgu/archive/2004/05/27/143221.aspx">blogosphere</a>.<p>
This is a nice, fairly self-contained, language design exercise.<p>
Should languages provide such a feature, and if they do, how should nullable types behave (e.g., does null==null ?).<p>
A DSL I worked on that was used for data analysis had two special values represeting missing and erroneous data. Builtin functions each had to decide how to handle these special values. It was quite useful in practice.<p><br>
			<font size="-2"><b>Posted to <a href='general.html'>general</a> by <a href='http://lambda-the-ultimate.org/'>Ehud Lamm</a> on 5/29/04; 3:42:35 AM</b><br>
			</font><br>
			<font size="-2">  </font>
			</td>
		<td valign="top" align="right" width="15%">
			
			</td>
		</tr>
	</table>
<p>
<p></p>
<p><a href='#12542'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Andris Birkmanis</a> - Re: Nullable Types <a name="12543">&nbsp;</a><a href='#12543' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/29/2004; 7:03:00 AM (reads: 568, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
So now the unboxed types got the option to include null in their domain, as boxed types could do all the time.
What about making them equal, and provide an option for the boxed ones to exclude null?
Like:<p>

	<blockquote>Integer! iCannotBeNull;</blockquote><p>


Then again, what would be the difference between "Integer!" and "int"? And between "Integer" and "int?"?.
<p></p>
<p><a href='#12543'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Patrick Logan</a> - Re: Nullable Types <a name="12545">&nbsp;</a><a href='#12545' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/29/2004; 6:26:42 PM (reads: 499, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
<i>What about making them equal...</i><p>

Indeed, the entire Nullable Type concept in C# 2.0 arises due to there being "special" data types (<code>int</code>, etc.). Ironically, those types in C# were designed to be an improvement on Java by removing the <code>int</code> vs. <code>Integer</code> dichotomy. But instead of making them true objects, they became "part-time" objects.<p>

As part-time objects, variables of that type can never be <code>null</code>, hence the need for a similar *object* to have a "null-like" value in its domain.<p>

Sigh. Complexity on top of complexity to solve problems due to complexity.
<p></p>
<p><a href='#12545'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Dave Herman</a> - Re: Nullable Types <a name="12548">&nbsp;</a><a href='#12548' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/29/2004; 8:06:12 PM (reads: 491, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
FWIW, I recall that <a href="http://nice.sourceforge.net">Nice</a> has <a href="http://nice.sourceforge.net/manual.html#optionTypes">something relevant</a>.
<p></p>
<p><a href='#12548'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Tim Sweeney</a> - Re: Nullable Types <a name="12565">&nbsp;</a><a href='#12565' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/31/2004; 6:15:22 PM (reads: 331, responses: 1)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
The existance of the "null pointer" is a language design mistake dating back three decades.  Instead of keeping the notions of "pointers to elements of type t" and "type t extended with an additional 'null' value" separate, C combined the two orthogonal notions into a single type constructor: pointers that might be 'null'. C++ confused things further by defining references in a way that makes it look like they can't be null, though they actually can be!<p>

There is a much cleaner way of implementing pointers:<p>

- For every type t, the type ^t represents "the type of pointers to elements of type t".  These include only the actual pointers which can be safely dereferenced.<p>

- For every type t, the type ?t represents "either an element of t or the special 'null' value".<p>

- Then ?^t is the equivalant of "pointers that may be null".  Define a shortcut syntax for this: *t = ?^t, and there!  You have backwards compatibility and a more sensible type theory.<p>

Unfortunately, C# confuses pointers and objects and mutability issues in so many other ways that such implementing this orthogonality is probably not worthwhile.
<p></p>
<p><a href='#12565'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Pseudonym</a> - Re: Nullable Types <a name="12566">&nbsp;</a><a href='#12566' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/31/2004; 8:12:55 PM (reads: 320, responses: 1)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
Oddly enough, this is an issue that I had to deal with at work this week.  The question there was: When you sort values into order, where do the null values come?<p>

We put the nulls last, which is the opposite than a C programmer would expect.  The domain in question was implementing the Z39.50 IR protocol, which actually neglects to say what missing values mean when sorting.  (The Z39.50 protocol neglects to mention a lot of things.)  Our reasoning was that if you sort on a datanase field it's because you find that field interesting, and records with that field missing are comparatively uninteresting, hence they should go last.<p>

Like all DSLs, analysing the domain is often the only way to solve these issues.
<p></p>
<p><a href='#12566'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Ehud Lamm</a> - Re: Nullable Types <a name="12568">&nbsp;</a><a href='#12568' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">5/31/2004; 11:00:32 PM (reads: 314, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
<i>We put the nulls last</i><p>
That's how we did it as well, IIRC.
<p></p>
<p><a href='#12568'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Adam Vandenberg</a> - Re: Nullable Types <a name="12578">&nbsp;</a><a href='#12578' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">6/2/2004; 1:12:17 PM (reads: 201, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
.NET has a few different APIs for processing XML.<p>

XmlElement.GetAttribute() returns an empty string if you specify an attibute that doesn't exist; XmlReader.GetAttribute() returns null.<p>

Of course, string is already a class (not a struct), and therefore nullable.<p>

Apparently the former behavior is specified by the DOM:
<a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-666EE0F9">http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-666EE0F9</a><p>

And then Element.getAttributeNode() returns null for non-existant attributes. (I guess the DOM wants to be compatible with languages with non-nullable strings?)
<p></p>
<p><a href='#12578'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Dan Shappir</a> - Re: Nullable Types <a name="12581">&nbsp;</a><a href='#12581' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">6/3/2004; 2:32:41 AM (reads: 182, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
I was going to respond to Tim's post but <a href="http://www.hutteman.com/weblog/2004/06/02-181.html">Luke Hutteman</a> pretty much summarized all I had to say.
<p></p>
<p><a href='#12581'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table>
<table cellpadding="0" cellspacing="0" width="100%" style="border: 1px solid navy; border-top: none;">
<tr bgcolor="skyblue">
<td>
<table width="100%" cellpadding="3" cellspacing="0"><tr>
<td>
<a href='http://lambda-the-ultimate.org/'>Frank Atanassow</a> - Re: Nullable Types <a name="12584">&nbsp;</a><a href='#12584' ><img src='leftArrow.gif' height="9" width="11" border="0" alt="blueArrow"></a><br>
<font size="-1">6/3/2004; 11:21:16 AM (reads: 169, responses: 0)</font>
</td>
</tr></table>
</td>
</tr>
<tr><td>
<table width="100%" cellpadding="3" cellspacing="0" style="border-top: 1px solid navy;"><tr><td>
Tim: <em>[everything]</em><p>

Everything you say is right on target.<p>

Pseudonym: <em>When you sort values into order, where do the null values come? We put the nulls last</em><p>

This is really a bogus question, which stems from the belief that everything in the world is linearly orderable in a unique way (which is patently wrong) or, less dogmatically, from the limitations of languages which can only comforably support one way to order values of a type. (The latter includes Haskell, BTW.)<p>

The truth is, there are many ways to order things. If I add an element to an ordered set, and I want to produce another ordered set, then there are many ways to do it, and putting the element at the beginning or end are only two possibilities, and in some applications one, both or neither will be the right choice.<p>

Therefore, the only sensible, general-purpose way to regard an order is not as a property intrinsic to a set, but rather as a structure one places <em>upon</em> a set.<p>

Of course, someone will say, "But hey, the natural numbers are intrinsically ordered, aren't they?" The answer is, Yes, if you regard them as an object of the category of linearly ordered sets (sets paired with a linear order), but: No, if you regard them as an object of the category of sets, because then the order comes from the arrow structure of the category, not the object structure.
<p></p>
<p><a href='#12584'><img src='skull.gif' height="18" width="22" border="0"></a></p>
</td></tr></table>
</td></tr>
</table><p>

</td></tr>
</table><p>


<p>
</td>
</tr>
</table></body></html>
