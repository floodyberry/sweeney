http://lambda-the-ultimate.org/node/1270
http://lambda-the-ultimate.org/node/1270#comment-14111
1049846
Naked Objects
Introspection
<p>Languages built on modern type theories guarantee many universal properties which assure that your program does what it says it's going to do.  One example is the parametricity theorem (see Wadler's "Theorems for Free").  It guarantees that a program cannot decompose values belonging to a universal type, an important security property enabling you to (for example) call functions in another module with the assurance that they can't do anything malicious with the data.
</p><p>Introspection, reflection, and even support for unconstrained casting (e.g. from Object to Integer in Java) all violate that property.  Therefore, unlimited introspection is not a desirable property in a secure language.  (C, C++, Java, C#, and Python aren't secure languages in this regard.)
</p><p>However, explicit programmer-controlled introspection is a good and reasonable feature.  For example, when defining a data type, it would be nice if a language offered a mechanism for specifying that associated metadata should be generated that describes the structure of that data, which may only be directly accessed by the module that contains the definition, but may be passed around to other modules explicitly by the programmer.
</p><p>More concretely, when I define a type T in the local scope, I should be able to syntactically specify that the compiler should generate a data structure describing T's layout (call it T.metadata, for example), and to make that data public or private.  I can then pass that metadata around to dependent-typed functions along with values of that type so that it can be deconstructed -- if I explicitly allow it to be.  But, given just a value of some arbitrary type, one should not be able to extract its "type", since that notion violates many universal properties (such as the subtyping property).
</p><p>Haskell typeclasses enable one to explicitly (not automatically) define metadata associated with a type in this way, and in the Haskell world this is done without violating the language's universal properties.  A more automated mechanism ("deriving TypeInfo"?) would make this more user-friendly.</p>