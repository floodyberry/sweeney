http://lambda-the-ultimate.org/node/1655
http://lambda-the-ultimate.org/node/1655#comment-20249
1050231
Overloading : Why do some languages leave it out?
Overloading is hard
<p>Overloading is frequently neglected because it is difficult.  The more advanced your type system, the more difficult overloading can be.  Key problems:
</p><p>In type systems supporting coercions and conversions between disjoint types (e.g. C's automatic casting from char to int), ambiguities arise regarding which combination of coercions and overloads should be effective for a given function invocation.  C++ deals with this by specifying a set of priority rules to determine the "best" overload.
</p><p>In type systems supporting universal quantification over types (implicit or explicit), overloading isn't an entirely local feature.  For example, if we defined (Haskell syntax) overloads f::int-&gt;int and f::string-&gt;string, we could then define g x = f.  To write a type signature for that, you need additional type system features (intersection types are one solution).  You likely also need the ability to represent polymorphic values at runtime (e.g. values of the union of the types int and string) and cast them, because at a given declaration site, you don't know which particular types are effective.
</p><p>In general, the type of the overloaded function f could be expressed (int-&gt;int)*(string-&gt;string) where * is the type intersection operator.  Or you could write it "exists(t=int|string) t-&gt;t" where we existentially quantify over the two choices for t, int and string.  There are many other workable solutions.
</p><p>In type systems with the parametricity property, overloading is required to be implemented "honestly".  In general, you can only support overloading over types whose values are unambiguously distinguishable.  For example, if function spaces are contravariant, then you can't overload f::(int-&gt;int)-&gt;bool and f::(string-&gt;string)-&gt;bool, because you can't distinguish int-&gt;int and string-&gt;string -- they both include larger functions such as forall t. t-&gt;t.
</p><p>To me, the key to sane overloading in a language is the ability for your compiler to implement it as syntactic sugar, and translate it into simpler primitives in a core language.  In other words, given two definitions f::t-&gt;u=.. and f::v-&gt;w=.., the compiler should be able to output an equivalant single function f=.. which is semantically equivalant to the overloaded function -- it must accept the same parameters either functions accepts, reject any functions both reject, produce the proper result with no unexpected side effects, and give a suitable error if the overload is ambiguous.
</p><p>That this isn't possible in most languages is an indication of their failures to implement a "complete" type system.
</p><p>What does "complete" mean?  For a simple type system with invariant functions, you need union types and casting to implement overloading. This is the easy case. 
</p><p>The translation is more tricky with contravariant functions, because some overloads become ambiguous.  Universal quantification complicates it further -- now you need the ability to combine multiple universal quantifications into one, over a function in which only some of the quantifiers can be implicitly instantiated.  Existential types add another layer of complexity, as do dependent types, etc.
</p><p>But I think it is vital for a programming language to choose a feature set that is complete with respect to overloading, lest its expressiveness be crippled in surprising ways.  For every advanced type system feature you expose, you need to say exactly how it works (or doesn't) in the presence of overloading.</p>